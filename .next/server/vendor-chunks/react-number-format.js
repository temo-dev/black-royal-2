"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-number-format";
exports.ids = ["vendor-chunks/react-number-format"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-number-format/dist/react-number-format.es.js":
/*!*************************************************************************!*\
  !*** ./node_modules/react-number-format/dist/react-number-format.es.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NumberFormatBase: () => (/* binding */ NumberFormatBase),\n/* harmony export */   NumericFormat: () => (/* binding */ NumericFormat),\n/* harmony export */   PatternFormat: () => (/* binding */ PatternFormat),\n/* harmony export */   getNumericCaretBoundary: () => (/* binding */ getCaretBoundary),\n/* harmony export */   getPatternCaretBoundary: () => (/* binding */ getCaretBoundary$1),\n/* harmony export */   numericFormatter: () => (/* binding */ format),\n/* harmony export */   patternFormatter: () => (/* binding */ format$1),\n/* harmony export */   removeNumericFormat: () => (/* binding */ removeFormatting),\n/* harmony export */   removePatternFormat: () => (/* binding */ removeFormatting$1),\n/* harmony export */   useNumericFormat: () => (/* binding */ useNumericFormat),\n/* harmony export */   usePatternFormat: () => (/* binding */ usePatternFormat)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/**\n * react-number-format - 5.4.0\n * Author : Sudhanshu Yadav\n * Copyright (c) 2016, 2024 to Sudhanshu Yadav, released under the MIT license.\n * https://github.com/s-yadav/react-number-format\n */ \n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ function __rest(s, e) {\n    var t = {};\n    for(var p in s){\n        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) {\n            t[p] = s[p];\n        }\n    }\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") {\n        for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) {\n                t[p[i]] = s[p[i]];\n            }\n        }\n    }\n    return t;\n}\nvar SourceType;\n(function(SourceType) {\n    SourceType[\"event\"] = \"event\";\n    SourceType[\"props\"] = \"prop\";\n})(SourceType || (SourceType = {}));\n// basic noop function\nfunction noop() {}\nfunction memoizeOnce(cb) {\n    var lastArgs;\n    var lastValue = undefined;\n    return function() {\n        var args = [], len = arguments.length;\n        while(len--)args[len] = arguments[len];\n        if (lastArgs && args.length === lastArgs.length && args.every(function(value, index) {\n            return value === lastArgs[index];\n        })) {\n            return lastValue;\n        }\n        lastArgs = args;\n        lastValue = cb.apply(void 0, args);\n        return lastValue;\n    };\n}\nfunction charIsNumber(char) {\n    return !!(char || \"\").match(/\\d/);\n}\nfunction isNil(val) {\n    return val === null || val === undefined;\n}\nfunction isNanValue(val) {\n    return typeof val === \"number\" && isNaN(val);\n}\nfunction isNotValidValue(val) {\n    return isNil(val) || isNanValue(val) || typeof val === \"number\" && !isFinite(val);\n}\nfunction escapeRegExp(str) {\n    return str.replace(/[-[\\]/{}()*+?.\\\\^$|]/g, \"\\\\$&\");\n}\nfunction getThousandsGroupRegex(thousandsGroupStyle) {\n    switch(thousandsGroupStyle){\n        case \"lakh\":\n            return /(\\d+?)(?=(\\d\\d)+(\\d)(?!\\d))(\\.\\d+)?/g;\n        case \"wan\":\n            return /(\\d)(?=(\\d{4})+(?!\\d))/g;\n        case \"thousand\":\n        default:\n            return /(\\d)(?=(\\d{3})+(?!\\d))/g;\n    }\n}\nfunction applyThousandSeparator(str, thousandSeparator, thousandsGroupStyle) {\n    var thousandsGroupRegex = getThousandsGroupRegex(thousandsGroupStyle);\n    var index = str.search(/[1-9]/);\n    index = index === -1 ? str.length : index;\n    return str.substring(0, index) + str.substring(index, str.length).replace(thousandsGroupRegex, \"$1\" + thousandSeparator);\n}\nfunction usePersistentCallback(cb) {\n    var callbackRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(cb);\n    // keep the callback ref upto date\n    callbackRef.current = cb;\n    /**\n     * initialize a persistent callback which never changes\n     * through out the component lifecycle\n     */ var persistentCbRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(function() {\n        var args = [], len = arguments.length;\n        while(len--)args[len] = arguments[len];\n        return callbackRef.current.apply(callbackRef, args);\n    });\n    return persistentCbRef.current;\n}\n//spilt a float number into different parts beforeDecimal, afterDecimal, and negation\nfunction splitDecimal(numStr, allowNegative) {\n    if (allowNegative === void 0) allowNegative = true;\n    var hasNegation = numStr[0] === \"-\";\n    var addNegation = hasNegation && allowNegative;\n    numStr = numStr.replace(\"-\", \"\");\n    var parts = numStr.split(\".\");\n    var beforeDecimal = parts[0];\n    var afterDecimal = parts[1] || \"\";\n    return {\n        beforeDecimal: beforeDecimal,\n        afterDecimal: afterDecimal,\n        hasNegation: hasNegation,\n        addNegation: addNegation\n    };\n}\nfunction fixLeadingZero(numStr) {\n    if (!numStr) {\n        return numStr;\n    }\n    var isNegative = numStr[0] === \"-\";\n    if (isNegative) {\n        numStr = numStr.substring(1, numStr.length);\n    }\n    var parts = numStr.split(\".\");\n    var beforeDecimal = parts[0].replace(/^0+/, \"\") || \"0\";\n    var afterDecimal = parts[1] || \"\";\n    return \"\" + (isNegative ? \"-\" : \"\") + beforeDecimal + (afterDecimal ? \".\" + afterDecimal : \"\");\n}\n/**\n * limit decimal numbers to given scale\n * Not used .fixedTo because that will break with big numbers\n */ function limitToScale(numStr, scale, fixedDecimalScale) {\n    var str = \"\";\n    var filler = fixedDecimalScale ? \"0\" : \"\";\n    for(var i = 0; i <= scale - 1; i++){\n        str += numStr[i] || filler;\n    }\n    return str;\n}\nfunction repeat(str, count) {\n    return Array(count + 1).join(str);\n}\nfunction toNumericString(num) {\n    var _num = num + \"\"; // typecast number to string\n    // store the sign and remove it from the number.\n    var sign = _num[0] === \"-\" ? \"-\" : \"\";\n    if (sign) {\n        _num = _num.substring(1);\n    }\n    // split the number into cofficient and exponent\n    var ref = _num.split(/[eE]/g);\n    var coefficient = ref[0];\n    var exponent = ref[1];\n    // covert exponent to number;\n    exponent = Number(exponent);\n    // if there is no exponent part or its 0, return the coffiecient with sign\n    if (!exponent) {\n        return sign + coefficient;\n    }\n    coefficient = coefficient.replace(\".\", \"\");\n    /**\n     * for scientific notation the current decimal index will be after first number (index 0)\n     * So effective decimal index will always be 1 + exponent value\n     */ var decimalIndex = 1 + exponent;\n    var coffiecientLn = coefficient.length;\n    if (decimalIndex < 0) {\n        // if decimal index is less then 0 add preceding 0s\n        // add 1 as join will have\n        coefficient = \"0.\" + repeat(\"0\", Math.abs(decimalIndex)) + coefficient;\n    } else if (decimalIndex >= coffiecientLn) {\n        // if decimal index is less then 0 add leading 0s\n        coefficient = coefficient + repeat(\"0\", decimalIndex - coffiecientLn);\n    } else {\n        // else add decimal point at proper index\n        coefficient = (coefficient.substring(0, decimalIndex) || \"0\") + \".\" + coefficient.substring(decimalIndex);\n    }\n    return sign + coefficient;\n}\n/**\n * This method is required to round prop value to given scale.\n * Not used .round or .fixedTo because that will break with big numbers\n */ function roundToPrecision(numStr, scale, fixedDecimalScale) {\n    //if number is empty don't do anything return empty string\n    if ([\n        \"\",\n        \"-\"\n    ].indexOf(numStr) !== -1) {\n        return numStr;\n    }\n    var shouldHaveDecimalSeparator = (numStr.indexOf(\".\") !== -1 || fixedDecimalScale) && scale;\n    var ref = splitDecimal(numStr);\n    var beforeDecimal = ref.beforeDecimal;\n    var afterDecimal = ref.afterDecimal;\n    var hasNegation = ref.hasNegation;\n    var floatValue = parseFloat(\"0.\" + (afterDecimal || \"0\"));\n    var floatValueStr = afterDecimal.length <= scale ? \"0.\" + afterDecimal : floatValue.toFixed(scale);\n    var roundedDecimalParts = floatValueStr.split(\".\");\n    var intPart = beforeDecimal;\n    // if we have cary over from rounding decimal part, add that on before decimal\n    if (beforeDecimal && Number(roundedDecimalParts[0])) {\n        intPart = beforeDecimal.split(\"\").reverse().reduce(function(roundedStr, current, idx) {\n            if (roundedStr.length > idx) {\n                return (Number(roundedStr[0]) + Number(current)).toString() + roundedStr.substring(1, roundedStr.length);\n            }\n            return current + roundedStr;\n        }, roundedDecimalParts[0]);\n    }\n    var decimalPart = limitToScale(roundedDecimalParts[1] || \"\", scale, fixedDecimalScale);\n    var negation = hasNegation ? \"-\" : \"\";\n    var decimalSeparator = shouldHaveDecimalSeparator ? \".\" : \"\";\n    return \"\" + negation + intPart + decimalSeparator + decimalPart;\n}\n/** set the caret positon in an input field **/ function setCaretPosition(el, caretPos) {\n    el.value = el.value;\n    // ^ this is used to not only get 'focus', but\n    // to make sure we don't have it everything -selected-\n    // (it causes an issue in chrome, and having it doesn't hurt any other browser)\n    if (el !== null) {\n        /* @ts-ignore */ if (el.createTextRange) {\n            /* @ts-ignore */ var range = el.createTextRange();\n            range.move(\"character\", caretPos);\n            range.select();\n            return true;\n        }\n        // (el.selectionStart === 0 added for Firefox bug)\n        if (el.selectionStart || el.selectionStart === 0) {\n            el.focus();\n            el.setSelectionRange(caretPos, caretPos);\n            return true;\n        }\n        // fail city, fortunately this never happens (as far as I've tested) :)\n        el.focus();\n        return false;\n    }\n}\n/**\n * TODO: remove dependency of findChangeRange, findChangedRangeFromCaretPositions is better way to find what is changed\n * currently this is mostly required by test and isCharacterSame util\n * Given previous value and newValue it returns the index\n * start - end to which values have changed.\n * This function makes assumption about only consecutive\n * characters are changed which is correct assumption for caret input.\n */ var findChangeRange = memoizeOnce(function(prevValue, newValue) {\n    var i = 0, j = 0;\n    var prevLength = prevValue.length;\n    var newLength = newValue.length;\n    while(prevValue[i] === newValue[i] && i < prevLength){\n        i++;\n    }\n    //check what has been changed from last\n    while(prevValue[prevLength - 1 - j] === newValue[newLength - 1 - j] && newLength - j > i && prevLength - j > i){\n        j++;\n    }\n    return {\n        from: {\n            start: i,\n            end: prevLength - j\n        },\n        to: {\n            start: i,\n            end: newLength - j\n        }\n    };\n});\nvar findChangedRangeFromCaretPositions = function(lastCaretPositions, currentCaretPosition) {\n    var startPosition = Math.min(lastCaretPositions.selectionStart, currentCaretPosition);\n    return {\n        from: {\n            start: startPosition,\n            end: lastCaretPositions.selectionEnd\n        },\n        to: {\n            start: startPosition,\n            end: currentCaretPosition\n        }\n    };\n};\n/*\n  Returns a number whose value is limited to the given range\n*/ function clamp(num, min, max) {\n    return Math.min(Math.max(num, min), max);\n}\nfunction geInputCaretPosition(el) {\n    /*Max of selectionStart and selectionEnd is taken for the patch of pixel and other mobile device caret bug*/ return Math.max(el.selectionStart, el.selectionEnd);\n}\nfunction addInputMode() {\n    return typeof navigator !== \"undefined\" && !(navigator.platform && /iPhone|iPod/.test(navigator.platform));\n}\nfunction getDefaultChangeMeta(value) {\n    return {\n        from: {\n            start: 0,\n            end: 0\n        },\n        to: {\n            start: 0,\n            end: value.length\n        },\n        lastValue: \"\"\n    };\n}\nfunction getMaskAtIndex(mask, index) {\n    if (mask === void 0) mask = \" \";\n    if (typeof mask === \"string\") {\n        return mask;\n    }\n    return mask[index] || \" \";\n}\nfunction defaultIsCharacterSame(ref) {\n    var currentValue = ref.currentValue;\n    var formattedValue = ref.formattedValue;\n    var currentValueIndex = ref.currentValueIndex;\n    var formattedValueIndex = ref.formattedValueIndex;\n    return currentValue[currentValueIndex] === formattedValue[formattedValueIndex];\n}\nfunction getCaretPosition(newFormattedValue, lastFormattedValue, curValue, curCaretPos, boundary, isValidInputCharacter, /**\n * format function can change the character, the caret engine relies on mapping old value and new value\n * In such case if character is changed, parent can tell which chars are equivalent\n * Some example, all allowedDecimalCharacters are updated to decimalCharacters, 2nd case if user is coverting\n * number to different numeric system.\n */ isCharacterSame) {\n    if (isCharacterSame === void 0) isCharacterSame = defaultIsCharacterSame;\n    /**\n     * if something got inserted on empty value, add the formatted character before the current value,\n     * This is to avoid the case where typed character is present on format characters\n     */ var firstAllowedPosition = boundary.findIndex(function(b) {\n        return b;\n    });\n    var prefixFormat = newFormattedValue.slice(0, firstAllowedPosition);\n    if (!lastFormattedValue && !curValue.startsWith(prefixFormat)) {\n        lastFormattedValue = prefixFormat;\n        curValue = prefixFormat + curValue;\n        curCaretPos = curCaretPos + prefixFormat.length;\n    }\n    var curValLn = curValue.length;\n    var formattedValueLn = newFormattedValue.length;\n    // create index map\n    var addedIndexMap = {};\n    var indexMap = new Array(curValLn);\n    for(var i = 0; i < curValLn; i++){\n        indexMap[i] = -1;\n        for(var j = 0, jLn = formattedValueLn; j < jLn; j++){\n            var isCharSame = isCharacterSame({\n                currentValue: curValue,\n                lastValue: lastFormattedValue,\n                formattedValue: newFormattedValue,\n                currentValueIndex: i,\n                formattedValueIndex: j\n            });\n            if (isCharSame && addedIndexMap[j] !== true) {\n                indexMap[i] = j;\n                addedIndexMap[j] = true;\n                break;\n            }\n        }\n    }\n    /**\n     * For current caret position find closest characters (left and right side)\n     * which are properly mapped to formatted value.\n     * The idea is that the new caret position will exist always in the boundary of\n     * that mapped index\n     */ var pos = curCaretPos;\n    while(pos < curValLn && (indexMap[pos] === -1 || !isValidInputCharacter(curValue[pos]))){\n        pos++;\n    }\n    // if the caret position is on last keep the endIndex as last for formatted value\n    var endIndex = pos === curValLn || indexMap[pos] === -1 ? formattedValueLn : indexMap[pos];\n    pos = curCaretPos - 1;\n    while(pos > 0 && indexMap[pos] === -1){\n        pos--;\n    }\n    var startIndex = pos === -1 || indexMap[pos] === -1 ? 0 : indexMap[pos] + 1;\n    /**\n     * case where a char is added on suffix and removed from middle, example 2sq345 becoming $2,345 sq\n     * there is still a mapping but the order of start index and end index is changed\n     */ if (startIndex > endIndex) {\n        return endIndex;\n    }\n    /**\n     * given the current caret position if it closer to startIndex\n     * keep the new caret position on start index or keep it closer to endIndex\n     */ return curCaretPos - startIndex < endIndex - curCaretPos ? startIndex : endIndex;\n}\n/* This keeps the caret within typing area so people can't type in between prefix or suffix or format characters */ function getCaretPosInBoundary(value, caretPos, boundary, direction) {\n    var valLn = value.length;\n    // clamp caret position to [0, value.length]\n    caretPos = clamp(caretPos, 0, valLn);\n    if (direction === \"left\") {\n        while(caretPos >= 0 && !boundary[caretPos]){\n            caretPos--;\n        }\n        // if we don't find any suitable caret position on left, set it on first allowed position\n        if (caretPos === -1) {\n            caretPos = boundary.indexOf(true);\n        }\n    } else {\n        while(caretPos <= valLn && !boundary[caretPos]){\n            caretPos++;\n        }\n        // if we don't find any suitable caret position on right, set it on last allowed position\n        if (caretPos > valLn) {\n            caretPos = boundary.lastIndexOf(true);\n        }\n    }\n    // if we still don't find caret position, set it at the end of value\n    if (caretPos === -1) {\n        caretPos = valLn;\n    }\n    return caretPos;\n}\nfunction caretUnknownFormatBoundary(formattedValue) {\n    var boundaryAry = Array.from({\n        length: formattedValue.length + 1\n    }).map(function() {\n        return true;\n    });\n    for(var i = 0, ln = boundaryAry.length; i < ln; i++){\n        // consider caret to be in boundary if it is before or after numeric value\n        boundaryAry[i] = Boolean(charIsNumber(formattedValue[i]) || charIsNumber(formattedValue[i - 1]));\n    }\n    return boundaryAry;\n}\nfunction useInternalValues(value, defaultValue, valueIsNumericString, format, removeFormatting, onValueChange) {\n    if (onValueChange === void 0) onValueChange = noop;\n    var getValues = usePersistentCallback(function(value, valueIsNumericString) {\n        var formattedValue, numAsString;\n        if (isNotValidValue(value)) {\n            numAsString = \"\";\n            formattedValue = \"\";\n        } else if (typeof value === \"number\" || valueIsNumericString) {\n            numAsString = typeof value === \"number\" ? toNumericString(value) : value;\n            formattedValue = format(numAsString);\n        } else {\n            numAsString = removeFormatting(value, undefined);\n            formattedValue = format(numAsString);\n        }\n        return {\n            formattedValue: formattedValue,\n            numAsString: numAsString\n        };\n    });\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(function() {\n        return getValues(isNil(value) ? defaultValue : value, valueIsNumericString);\n    });\n    var values = ref[0];\n    var setValues = ref[1];\n    var _onValueChange = function(newValues, sourceInfo) {\n        if (newValues.formattedValue !== values.formattedValue) {\n            setValues({\n                formattedValue: newValues.formattedValue,\n                numAsString: newValues.value\n            });\n        }\n        // call parent on value change if only if formatted value is changed\n        onValueChange(newValues, sourceInfo);\n    };\n    // if value is switch from controlled to uncontrolled, use the internal state's value to format with new props\n    var _value = value;\n    var _valueIsNumericString = valueIsNumericString;\n    if (isNil(value)) {\n        _value = values.numAsString;\n        _valueIsNumericString = true;\n    }\n    var newValues = getValues(_value, _valueIsNumericString);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function() {\n        setValues(newValues);\n    }, [\n        newValues.formattedValue\n    ]);\n    return [\n        values,\n        _onValueChange\n    ];\n}\nfunction defaultRemoveFormatting(value) {\n    return value.replace(/[^0-9]/g, \"\");\n}\nfunction defaultFormat(value) {\n    return value;\n}\nfunction NumberFormatBase(props) {\n    var type = props.type;\n    if (type === void 0) type = \"text\";\n    var displayType = props.displayType;\n    if (displayType === void 0) displayType = \"input\";\n    var customInput = props.customInput;\n    var renderText = props.renderText;\n    var getInputRef = props.getInputRef;\n    var format = props.format;\n    if (format === void 0) format = defaultFormat;\n    var removeFormatting = props.removeFormatting;\n    if (removeFormatting === void 0) removeFormatting = defaultRemoveFormatting;\n    var defaultValue = props.defaultValue;\n    var valueIsNumericString = props.valueIsNumericString;\n    var onValueChange = props.onValueChange;\n    var isAllowed = props.isAllowed;\n    var onChange = props.onChange;\n    if (onChange === void 0) onChange = noop;\n    var onKeyDown = props.onKeyDown;\n    if (onKeyDown === void 0) onKeyDown = noop;\n    var onMouseUp = props.onMouseUp;\n    if (onMouseUp === void 0) onMouseUp = noop;\n    var onFocus = props.onFocus;\n    if (onFocus === void 0) onFocus = noop;\n    var onBlur = props.onBlur;\n    if (onBlur === void 0) onBlur = noop;\n    var propValue = props.value;\n    var getCaretBoundary = props.getCaretBoundary;\n    if (getCaretBoundary === void 0) getCaretBoundary = caretUnknownFormatBoundary;\n    var isValidInputCharacter = props.isValidInputCharacter;\n    if (isValidInputCharacter === void 0) isValidInputCharacter = charIsNumber;\n    var isCharacterSame = props.isCharacterSame;\n    var otherProps = __rest(props, [\n        \"type\",\n        \"displayType\",\n        \"customInput\",\n        \"renderText\",\n        \"getInputRef\",\n        \"format\",\n        \"removeFormatting\",\n        \"defaultValue\",\n        \"valueIsNumericString\",\n        \"onValueChange\",\n        \"isAllowed\",\n        \"onChange\",\n        \"onKeyDown\",\n        \"onMouseUp\",\n        \"onFocus\",\n        \"onBlur\",\n        \"value\",\n        \"getCaretBoundary\",\n        \"isValidInputCharacter\",\n        \"isCharacterSame\"\n    ]);\n    var ref = useInternalValues(propValue, defaultValue, Boolean(valueIsNumericString), format, removeFormatting, onValueChange);\n    var ref_0 = ref[0];\n    var formattedValue = ref_0.formattedValue;\n    var numAsString = ref_0.numAsString;\n    var onFormattedValueChange = ref[1];\n    var caretPositionBeforeChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    var lastUpdatedValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        formattedValue: formattedValue,\n        numAsString: numAsString\n    });\n    var _onValueChange = function(values, source) {\n        lastUpdatedValue.current = {\n            formattedValue: values.formattedValue,\n            numAsString: values.value\n        };\n        onFormattedValueChange(values, source);\n    };\n    var ref$1 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    var mounted = ref$1[0];\n    var setMounted = ref$1[1];\n    var focusedElm = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var timeout = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        setCaretTimeout: null,\n        focusTimeout: null\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n        setMounted(true);\n        return function() {\n            clearTimeout(timeout.current.setCaretTimeout);\n            clearTimeout(timeout.current.focusTimeout);\n        };\n    }, []);\n    var _format = format;\n    var getValueObject = function(formattedValue, numAsString) {\n        var floatValue = parseFloat(numAsString);\n        return {\n            formattedValue: formattedValue,\n            value: numAsString,\n            floatValue: isNaN(floatValue) ? undefined : floatValue\n        };\n    };\n    var setPatchedCaretPosition = function(el, caretPos, currentValue) {\n        // don't reset the caret position when the whole input content is selected\n        if (el.selectionStart === 0 && el.selectionEnd === el.value.length) {\n            return;\n        }\n        /* setting caret position within timeout of 0ms is required for mobile chrome,\n        otherwise browser resets the caret position after we set it\n        We are also setting it without timeout so that in normal browser we don't see the flickering */ setCaretPosition(el, caretPos);\n        timeout.current.setCaretTimeout = setTimeout(function() {\n            if (el.value === currentValue && el.selectionStart !== caretPos) {\n                setCaretPosition(el, caretPos);\n            }\n        }, 0);\n    };\n    /* This keeps the caret within typing area so people can't type in between prefix or suffix */ var correctCaretPosition = function(value, caretPos, direction) {\n        return getCaretPosInBoundary(value, caretPos, getCaretBoundary(value), direction);\n    };\n    var getNewCaretPosition = function(inputValue, newFormattedValue, caretPos) {\n        var caretBoundary = getCaretBoundary(newFormattedValue);\n        var updatedCaretPos = getCaretPosition(newFormattedValue, formattedValue, inputValue, caretPos, caretBoundary, isValidInputCharacter, isCharacterSame);\n        //correct caret position if its outside of editable area\n        updatedCaretPos = getCaretPosInBoundary(newFormattedValue, updatedCaretPos, caretBoundary);\n        return updatedCaretPos;\n    };\n    var updateValueAndCaretPosition = function(params) {\n        var newFormattedValue = params.formattedValue;\n        if (newFormattedValue === void 0) newFormattedValue = \"\";\n        var input = params.input;\n        var source = params.source;\n        var event = params.event;\n        var numAsString = params.numAsString;\n        var caretPos;\n        if (input) {\n            var inputValue = params.inputValue || input.value;\n            var currentCaretPosition = geInputCaretPosition(input);\n            /**\n             * set the value imperatively, this is required for IE fix\n             * This is also required as if new caret position is beyond the previous value.\n             * Caret position will not be set correctly\n             */ input.value = newFormattedValue;\n            //get the caret position\n            caretPos = getNewCaretPosition(inputValue, newFormattedValue, currentCaretPosition);\n            //set caret position imperatively\n            if (caretPos !== undefined) {\n                setPatchedCaretPosition(input, caretPos, newFormattedValue);\n            }\n        }\n        if (newFormattedValue !== formattedValue) {\n            // trigger onValueChange synchronously, so parent is updated along with the number format. Fix for #277, #287\n            _onValueChange(getValueObject(newFormattedValue, numAsString), {\n                event: event,\n                source: source\n            });\n        }\n    };\n    /**\n     * if the formatted value is not synced to parent, or if the formatted value is different from last synced value sync it\n     * if the formatting props is removed, in which case last formatted value will be different from the numeric string value\n     * in such case we need to inform the parent.\n     */ (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n        var ref = lastUpdatedValue.current;\n        var lastFormattedValue = ref.formattedValue;\n        var lastNumAsString = ref.numAsString;\n        if (formattedValue !== lastFormattedValue || numAsString !== lastNumAsString) {\n            _onValueChange(getValueObject(formattedValue, numAsString), {\n                event: undefined,\n                source: SourceType.props\n            });\n        }\n    }, [\n        formattedValue,\n        numAsString\n    ]);\n    // also if formatted value is changed from the props, we need to update the caret position\n    // keep the last caret position if element is focused\n    var currentCaretPosition = focusedElm.current ? geInputCaretPosition(focusedElm.current) : undefined;\n    // needed to prevent warning with useLayoutEffect on server\n    var useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n    useIsomorphicLayoutEffect(function() {\n        var input = focusedElm.current;\n        if (formattedValue !== lastUpdatedValue.current.formattedValue && input) {\n            var caretPos = getNewCaretPosition(lastUpdatedValue.current.formattedValue, formattedValue, currentCaretPosition);\n            /**\n             * set the value imperatively, as we set the caret position as well imperatively.\n             * This is to keep value and caret position in sync\n             */ input.value = formattedValue;\n            setPatchedCaretPosition(input, caretPos, formattedValue);\n        }\n    }, [\n        formattedValue\n    ]);\n    var formatInputValue = function(inputValue, event, source) {\n        var input = event.target;\n        var changeRange = caretPositionBeforeChange.current ? findChangedRangeFromCaretPositions(caretPositionBeforeChange.current, input.selectionEnd) : findChangeRange(formattedValue, inputValue);\n        var changeMeta = Object.assign(Object.assign({}, changeRange), {\n            lastValue: formattedValue\n        });\n        var _numAsString = removeFormatting(inputValue, changeMeta);\n        var _formattedValue = _format(_numAsString);\n        // formatting can remove some of the number chars, so we need to fine number string again\n        _numAsString = removeFormatting(_formattedValue, undefined);\n        if (isAllowed && !isAllowed(getValueObject(_formattedValue, _numAsString))) {\n            //reset the caret position\n            var input$1 = event.target;\n            var currentCaretPosition = geInputCaretPosition(input$1);\n            var caretPos = getNewCaretPosition(inputValue, formattedValue, currentCaretPosition);\n            input$1.value = formattedValue;\n            setPatchedCaretPosition(input$1, caretPos, formattedValue);\n            return false;\n        }\n        updateValueAndCaretPosition({\n            formattedValue: _formattedValue,\n            numAsString: _numAsString,\n            inputValue: inputValue,\n            event: event,\n            source: source,\n            input: event.target\n        });\n        return true;\n    };\n    var setCaretPositionInfoBeforeChange = function(el, endOffset) {\n        if (endOffset === void 0) endOffset = 0;\n        var selectionStart = el.selectionStart;\n        var selectionEnd = el.selectionEnd;\n        caretPositionBeforeChange.current = {\n            selectionStart: selectionStart,\n            selectionEnd: selectionEnd + endOffset\n        };\n    };\n    var _onChange = function(e) {\n        var el = e.target;\n        var inputValue = el.value;\n        var changed = formatInputValue(inputValue, e, SourceType.event);\n        if (changed) {\n            onChange(e);\n        }\n        // reset the position, as we have already handled the caret position\n        caretPositionBeforeChange.current = undefined;\n    };\n    var _onKeyDown = function(e) {\n        var el = e.target;\n        var key = e.key;\n        var selectionStart = el.selectionStart;\n        var selectionEnd = el.selectionEnd;\n        var value = el.value;\n        if (value === void 0) value = \"\";\n        var expectedCaretPosition;\n        //Handle backspace and delete against non numerical/decimal characters or arrow keys\n        if (key === \"ArrowLeft\" || key === \"Backspace\") {\n            expectedCaretPosition = Math.max(selectionStart - 1, 0);\n        } else if (key === \"ArrowRight\") {\n            expectedCaretPosition = Math.min(selectionStart + 1, value.length);\n        } else if (key === \"Delete\") {\n            expectedCaretPosition = selectionStart;\n        }\n        // if key is delete and text is not selected keep the end offset to 1, as it deletes one character\n        // this is required as selection is not changed on delete case, which changes the change range calculation\n        var endOffset = 0;\n        if (key === \"Delete\" && selectionStart === selectionEnd) {\n            endOffset = 1;\n        }\n        var isArrowKey = key === \"ArrowLeft\" || key === \"ArrowRight\";\n        //if expectedCaretPosition is not set it means we don't want to Handle keyDown\n        // also if multiple characters are selected don't handle\n        if (expectedCaretPosition === undefined || selectionStart !== selectionEnd && !isArrowKey) {\n            onKeyDown(e);\n            // keep information of what was the caret position before keyDown\n            // set it after onKeyDown, in case parent updates the position manually\n            setCaretPositionInfoBeforeChange(el, endOffset);\n            return;\n        }\n        var newCaretPosition = expectedCaretPosition;\n        if (isArrowKey) {\n            var direction = key === \"ArrowLeft\" ? \"left\" : \"right\";\n            newCaretPosition = correctCaretPosition(value, expectedCaretPosition, direction);\n            // arrow left or right only moves the caret, so no need to handle the event, if we are handling it manually\n            if (newCaretPosition !== expectedCaretPosition) {\n                e.preventDefault();\n            }\n        } else if (key === \"Delete\" && !isValidInputCharacter(value[expectedCaretPosition])) {\n            // in case of delete go to closest caret boundary on the right side\n            newCaretPosition = correctCaretPosition(value, expectedCaretPosition, \"right\");\n        } else if (key === \"Backspace\" && !isValidInputCharacter(value[expectedCaretPosition])) {\n            // in case of backspace go to closest caret boundary on the left side\n            newCaretPosition = correctCaretPosition(value, expectedCaretPosition, \"left\");\n        }\n        if (newCaretPosition !== expectedCaretPosition) {\n            setPatchedCaretPosition(el, newCaretPosition, value);\n        }\n        onKeyDown(e);\n        setCaretPositionInfoBeforeChange(el, endOffset);\n    };\n    /** required to handle the caret position when click anywhere within the input **/ var _onMouseUp = function(e) {\n        var el = e.target;\n        /**\n         * NOTE: we have to give default value for value as in case when custom input is provided\n         * value can come as undefined when nothing is provided on value prop.\n         */ var correctCaretPositionIfRequired = function() {\n            var selectionStart = el.selectionStart;\n            var selectionEnd = el.selectionEnd;\n            var value = el.value;\n            if (value === void 0) value = \"\";\n            if (selectionStart === selectionEnd) {\n                var caretPosition = correctCaretPosition(value, selectionStart);\n                if (caretPosition !== selectionStart) {\n                    setPatchedCaretPosition(el, caretPosition, value);\n                }\n            }\n        };\n        correctCaretPositionIfRequired();\n        // try to correct after selection has updated by browser\n        // this case is required when user clicks on some position while a text is selected on input\n        requestAnimationFrame(function() {\n            correctCaretPositionIfRequired();\n        });\n        onMouseUp(e);\n        setCaretPositionInfoBeforeChange(el);\n    };\n    var _onFocus = function(e) {\n        // Workaround Chrome and Safari bug https://bugs.chromium.org/p/chromium/issues/detail?id=779328\n        // (onFocus event target selectionStart is always 0 before setTimeout)\n        if (e.persist) {\n            e.persist();\n        }\n        var el = e.target;\n        var currentTarget = e.currentTarget;\n        focusedElm.current = el;\n        timeout.current.focusTimeout = setTimeout(function() {\n            var selectionStart = el.selectionStart;\n            var selectionEnd = el.selectionEnd;\n            var value = el.value;\n            if (value === void 0) value = \"\";\n            var caretPosition = correctCaretPosition(value, selectionStart);\n            //setPatchedCaretPosition only when everything is not selected on focus (while tabbing into the field)\n            if (caretPosition !== selectionStart && !(selectionStart === 0 && selectionEnd === value.length)) {\n                setPatchedCaretPosition(el, caretPosition, value);\n            }\n            onFocus(Object.assign(Object.assign({}, e), {\n                currentTarget: currentTarget\n            }));\n        }, 0);\n    };\n    var _onBlur = function(e) {\n        focusedElm.current = null;\n        clearTimeout(timeout.current.focusTimeout);\n        clearTimeout(timeout.current.setCaretTimeout);\n        onBlur(e);\n    };\n    // add input mode on element based on format prop and device once the component is mounted\n    var inputMode = mounted && addInputMode() ? \"numeric\" : undefined;\n    var inputProps = Object.assign({\n        inputMode: inputMode\n    }, otherProps, {\n        type: type,\n        value: formattedValue,\n        onChange: _onChange,\n        onKeyDown: _onKeyDown,\n        onMouseUp: _onMouseUp,\n        onFocus: _onFocus,\n        onBlur: _onBlur\n    });\n    if (displayType === \"text\") {\n        return renderText ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, renderText(formattedValue, otherProps) || null) : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"span\", Object.assign({}, otherProps, {\n            ref: getInputRef\n        }), formattedValue);\n    } else if (customInput) {\n        var CustomInput = customInput;\n        /* @ts-ignore */ return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(CustomInput, Object.assign({}, inputProps, {\n            ref: getInputRef\n        }));\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"input\", Object.assign({}, inputProps, {\n        ref: getInputRef\n    }));\n}\nfunction format(numStr, props) {\n    var decimalScale = props.decimalScale;\n    var fixedDecimalScale = props.fixedDecimalScale;\n    var prefix = props.prefix;\n    if (prefix === void 0) prefix = \"\";\n    var suffix = props.suffix;\n    if (suffix === void 0) suffix = \"\";\n    var allowNegative = props.allowNegative;\n    var thousandsGroupStyle = props.thousandsGroupStyle;\n    if (thousandsGroupStyle === void 0) thousandsGroupStyle = \"thousand\";\n    // don't apply formatting on empty string or '-'\n    if (numStr === \"\" || numStr === \"-\") {\n        return numStr;\n    }\n    var ref = getSeparators(props);\n    var thousandSeparator = ref.thousandSeparator;\n    var decimalSeparator = ref.decimalSeparator;\n    /**\n     * Keep the decimal separator\n     * when decimalScale is not defined or non zero and the numStr has decimal in it\n     * Or if decimalScale is > 0 and fixeDecimalScale is true (even if numStr has no decimal)\n     */ var hasDecimalSeparator = decimalScale !== 0 && numStr.indexOf(\".\") !== -1 || decimalScale && fixedDecimalScale;\n    var ref$1 = splitDecimal(numStr, allowNegative);\n    var beforeDecimal = ref$1.beforeDecimal;\n    var afterDecimal = ref$1.afterDecimal;\n    var addNegation = ref$1.addNegation; // eslint-disable-line prefer-const\n    //apply decimal precision if its defined\n    if (decimalScale !== undefined) {\n        afterDecimal = limitToScale(afterDecimal, decimalScale, !!fixedDecimalScale);\n    }\n    if (thousandSeparator) {\n        beforeDecimal = applyThousandSeparator(beforeDecimal, thousandSeparator, thousandsGroupStyle);\n    }\n    //add prefix and suffix when there is a number present\n    if (prefix) {\n        beforeDecimal = prefix + beforeDecimal;\n    }\n    if (suffix) {\n        afterDecimal = afterDecimal + suffix;\n    }\n    //restore negation sign\n    if (addNegation) {\n        beforeDecimal = \"-\" + beforeDecimal;\n    }\n    numStr = beforeDecimal + (hasDecimalSeparator && decimalSeparator || \"\") + afterDecimal;\n    return numStr;\n}\nfunction getSeparators(props) {\n    var decimalSeparator = props.decimalSeparator;\n    if (decimalSeparator === void 0) decimalSeparator = \".\";\n    var thousandSeparator = props.thousandSeparator;\n    var allowedDecimalSeparators = props.allowedDecimalSeparators;\n    if (thousandSeparator === true) {\n        thousandSeparator = \",\";\n    }\n    if (!allowedDecimalSeparators) {\n        allowedDecimalSeparators = [\n            decimalSeparator,\n            \".\"\n        ];\n    }\n    return {\n        decimalSeparator: decimalSeparator,\n        thousandSeparator: thousandSeparator,\n        allowedDecimalSeparators: allowedDecimalSeparators\n    };\n}\nfunction handleNegation(value, allowNegative) {\n    if (value === void 0) value = \"\";\n    var negationRegex = new RegExp(\"(-)\");\n    var doubleNegationRegex = new RegExp(\"(-)(.)*(-)\");\n    // Check number has '-' value\n    var hasNegation = negationRegex.test(value);\n    // Check number has 2 or more '-' values\n    var removeNegation = doubleNegationRegex.test(value);\n    //remove negation\n    value = value.replace(/-/g, \"\");\n    if (hasNegation && !removeNegation && allowNegative) {\n        value = \"-\" + value;\n    }\n    return value;\n}\nfunction getNumberRegex(decimalSeparator, global) {\n    return new RegExp(\"(^-)|[0-9]|\" + escapeRegExp(decimalSeparator), global ? \"g\" : undefined);\n}\nfunction isNumericString(val, prefix, suffix) {\n    // for empty value we can always treat it as numeric string\n    if (val === \"\") {\n        return true;\n    }\n    return !(prefix === null || prefix === void 0 ? void 0 : prefix.match(/\\d/)) && !(suffix === null || suffix === void 0 ? void 0 : suffix.match(/\\d/)) && typeof val === \"string\" && !isNaN(Number(val));\n}\nfunction removeFormatting(value, changeMeta, props) {\n    var assign;\n    if (changeMeta === void 0) changeMeta = getDefaultChangeMeta(value);\n    var allowNegative = props.allowNegative;\n    var prefix = props.prefix;\n    if (prefix === void 0) prefix = \"\";\n    var suffix = props.suffix;\n    if (suffix === void 0) suffix = \"\";\n    var decimalScale = props.decimalScale;\n    var from = changeMeta.from;\n    var to = changeMeta.to;\n    var start = to.start;\n    var end = to.end;\n    var ref = getSeparators(props);\n    var allowedDecimalSeparators = ref.allowedDecimalSeparators;\n    var decimalSeparator = ref.decimalSeparator;\n    var isBeforeDecimalSeparator = value[end] === decimalSeparator;\n    /**\n     * If only a number is added on empty input which matches with the prefix or suffix,\n     * then don't remove it, just return the same\n     */ if (charIsNumber(value) && (value === prefix || value === suffix) && changeMeta.lastValue === \"\") {\n        return value;\n    }\n    /** Check for any allowed decimal separator is added in the numeric format and replace it with decimal separator */ if (end - start === 1 && allowedDecimalSeparators.indexOf(value[start]) !== -1) {\n        var separator = decimalScale === 0 ? \"\" : decimalSeparator;\n        value = value.substring(0, start) + separator + value.substring(start + 1, value.length);\n    }\n    var stripNegation = function(value, start, end) {\n        /**\n         * if prefix starts with - we don't allow negative number to avoid confusion\n         * if suffix starts with - and the value length is same as suffix length, then the - sign is from the suffix\n         * In other cases, if the value starts with - then it is a negation\n         */ var hasNegation = false;\n        var hasDoubleNegation = false;\n        if (prefix.startsWith(\"-\")) {\n            hasNegation = false;\n        } else if (value.startsWith(\"--\")) {\n            hasNegation = false;\n            hasDoubleNegation = true;\n        } else if (suffix.startsWith(\"-\") && value.length === suffix.length) {\n            hasNegation = false;\n        } else if (value[0] === \"-\") {\n            hasNegation = true;\n        }\n        var charsToRemove = hasNegation ? 1 : 0;\n        if (hasDoubleNegation) {\n            charsToRemove = 2;\n        }\n        // remove negation/double negation from start to simplify prefix logic as negation comes before prefix\n        if (charsToRemove) {\n            value = value.substring(charsToRemove);\n            // account for the removal of the negation for start and end index\n            start -= charsToRemove;\n            end -= charsToRemove;\n        }\n        return {\n            value: value,\n            start: start,\n            end: end,\n            hasNegation: hasNegation\n        };\n    };\n    var toMetadata = stripNegation(value, start, end);\n    var hasNegation = toMetadata.hasNegation;\n    assign = toMetadata, value = assign.value, start = assign.start, end = assign.end;\n    var ref$1 = stripNegation(changeMeta.lastValue, from.start, from.end);\n    var fromStart = ref$1.start;\n    var fromEnd = ref$1.end;\n    var lastValue = ref$1.value;\n    // if only prefix and suffix part is updated reset the value to last value\n    // if the changed range is from suffix in the updated value, and the the suffix starts with the same characters, allow the change\n    var updatedSuffixPart = value.substring(start, end);\n    if (value.length && lastValue.length && (fromStart > lastValue.length - suffix.length || fromEnd < prefix.length) && !(updatedSuffixPart && suffix.startsWith(updatedSuffixPart))) {\n        value = lastValue;\n    }\n    /**\n     * remove prefix\n     * Remove whole prefix part if its present on the value\n     * If the prefix is partially deleted (in which case change start index will be less the prefix length)\n     * Remove only partial part of prefix.\n     */ var startIndex = 0;\n    if (value.startsWith(prefix)) {\n        startIndex += prefix.length;\n    } else if (start < prefix.length) {\n        startIndex = start;\n    }\n    value = value.substring(startIndex);\n    // account for deleted prefix for end\n    end -= startIndex;\n    /**\n     * Remove suffix\n     * Remove whole suffix part if its present on the value\n     * If the suffix is partially deleted (in which case change end index will be greater than the suffixStartIndex)\n     * remove the partial part of suffix\n     */ var endIndex = value.length;\n    var suffixStartIndex = value.length - suffix.length;\n    if (value.endsWith(suffix)) {\n        endIndex = suffixStartIndex;\n    } else if (end > suffixStartIndex) {\n        endIndex = end;\n    } else if (end > value.length - suffix.length) {\n        endIndex = end;\n    }\n    value = value.substring(0, endIndex);\n    // add the negation back and handle for double negation\n    value = handleNegation(hasNegation ? \"-\" + value : value, allowNegative);\n    // remove non numeric characters\n    value = (value.match(getNumberRegex(decimalSeparator, true)) || []).join(\"\");\n    // replace the decimalSeparator with ., and only keep the first separator, ignore following ones\n    var firstIndex = value.indexOf(decimalSeparator);\n    value = value.replace(new RegExp(escapeRegExp(decimalSeparator), \"g\"), function(match, index) {\n        return index === firstIndex ? \".\" : \"\";\n    });\n    //check if beforeDecimal got deleted and there is nothing after decimal,\n    //clear all numbers in such case while keeping the - sign\n    var ref$2 = splitDecimal(value, allowNegative);\n    var beforeDecimal = ref$2.beforeDecimal;\n    var afterDecimal = ref$2.afterDecimal;\n    var addNegation = ref$2.addNegation; // eslint-disable-line prefer-const\n    //clear only if something got deleted before decimal (cursor is before decimal)\n    if (to.end - to.start < from.end - from.start && beforeDecimal === \"\" && isBeforeDecimalSeparator && !parseFloat(afterDecimal)) {\n        value = addNegation ? \"-\" : \"\";\n    }\n    return value;\n}\nfunction getCaretBoundary(formattedValue, props) {\n    var prefix = props.prefix;\n    if (prefix === void 0) prefix = \"\";\n    var suffix = props.suffix;\n    if (suffix === void 0) suffix = \"\";\n    var boundaryAry = Array.from({\n        length: formattedValue.length + 1\n    }).map(function() {\n        return true;\n    });\n    var hasNegation = formattedValue[0] === \"-\";\n    // fill for prefix and negation\n    boundaryAry.fill(false, 0, prefix.length + (hasNegation ? 1 : 0));\n    // fill for suffix\n    var valLn = formattedValue.length;\n    boundaryAry.fill(false, valLn - suffix.length + 1, valLn + 1);\n    return boundaryAry;\n}\nfunction validateAndUpdateProps(props) {\n    var ref = getSeparators(props);\n    var thousandSeparator = ref.thousandSeparator;\n    var decimalSeparator = ref.decimalSeparator;\n    // eslint-disable-next-line prefer-const\n    var prefix = props.prefix;\n    if (prefix === void 0) prefix = \"\";\n    var allowNegative = props.allowNegative;\n    if (allowNegative === void 0) allowNegative = true;\n    if (thousandSeparator === decimalSeparator) {\n        throw new Error(\"\\n        Decimal separator can't be same as thousand separator.\\n        thousandSeparator: \" + thousandSeparator + ' (thousandSeparator = {true} is same as thousandSeparator = \",\")\\n        decimalSeparator: ' + decimalSeparator + \" (default value for decimalSeparator is .)\\n     \");\n    }\n    if (prefix.startsWith(\"-\") && allowNegative) {\n        // TODO: throw error in next major version\n        console.error(\"\\n      Prefix can't start with '-' when allowNegative is true.\\n      prefix: \" + prefix + \"\\n      allowNegative: \" + allowNegative + \"\\n    \");\n        allowNegative = false;\n    }\n    return Object.assign(Object.assign({}, props), {\n        allowNegative: allowNegative\n    });\n}\nfunction useNumericFormat(props) {\n    // validate props\n    props = validateAndUpdateProps(props);\n    var _decimalSeparator = props.decimalSeparator;\n    var _allowedDecimalSeparators = props.allowedDecimalSeparators;\n    var thousandsGroupStyle = props.thousandsGroupStyle;\n    var suffix = props.suffix;\n    var allowNegative = props.allowNegative;\n    var allowLeadingZeros = props.allowLeadingZeros;\n    var onKeyDown = props.onKeyDown;\n    if (onKeyDown === void 0) onKeyDown = noop;\n    var onBlur = props.onBlur;\n    if (onBlur === void 0) onBlur = noop;\n    var thousandSeparator = props.thousandSeparator;\n    var decimalScale = props.decimalScale;\n    var fixedDecimalScale = props.fixedDecimalScale;\n    var prefix = props.prefix;\n    if (prefix === void 0) prefix = \"\";\n    var defaultValue = props.defaultValue;\n    var value = props.value;\n    var valueIsNumericString = props.valueIsNumericString;\n    var onValueChange = props.onValueChange;\n    var restProps = __rest(props, [\n        \"decimalSeparator\",\n        \"allowedDecimalSeparators\",\n        \"thousandsGroupStyle\",\n        \"suffix\",\n        \"allowNegative\",\n        \"allowLeadingZeros\",\n        \"onKeyDown\",\n        \"onBlur\",\n        \"thousandSeparator\",\n        \"decimalScale\",\n        \"fixedDecimalScale\",\n        \"prefix\",\n        \"defaultValue\",\n        \"value\",\n        \"valueIsNumericString\",\n        \"onValueChange\"\n    ]);\n    // get derived decimalSeparator and allowedDecimalSeparators\n    var ref = getSeparators(props);\n    var decimalSeparator = ref.decimalSeparator;\n    var allowedDecimalSeparators = ref.allowedDecimalSeparators;\n    var _format = function(numStr) {\n        return format(numStr, props);\n    };\n    var _removeFormatting = function(inputValue, changeMeta) {\n        return removeFormatting(inputValue, changeMeta, props);\n    };\n    var _value = isNil(value) ? defaultValue : value;\n    // try to figure out isValueNumericString based on format prop and value\n    var _valueIsNumericString = valueIsNumericString !== null && valueIsNumericString !== void 0 ? valueIsNumericString : isNumericString(_value, prefix, suffix);\n    if (!isNil(value)) {\n        _valueIsNumericString = _valueIsNumericString || typeof value === \"number\";\n    } else if (!isNil(defaultValue)) {\n        _valueIsNumericString = _valueIsNumericString || typeof defaultValue === \"number\";\n    }\n    var roundIncomingValueToPrecision = function(value) {\n        if (isNotValidValue(value)) {\n            return value;\n        }\n        if (typeof value === \"number\") {\n            value = toNumericString(value);\n        }\n        /**\n         * only round numeric or float string values coming through props,\n         * we don't need to do it for onChange events, as we want to prevent typing there\n         */ if (_valueIsNumericString && typeof decimalScale === \"number\") {\n            return roundToPrecision(value, decimalScale, Boolean(fixedDecimalScale));\n        }\n        return value;\n    };\n    var ref$1 = useInternalValues(roundIncomingValueToPrecision(value), roundIncomingValueToPrecision(defaultValue), Boolean(_valueIsNumericString), _format, _removeFormatting, onValueChange);\n    var ref$1_0 = ref$1[0];\n    var numAsString = ref$1_0.numAsString;\n    var formattedValue = ref$1_0.formattedValue;\n    var _onValueChange = ref$1[1];\n    var _onKeyDown = function(e) {\n        var el = e.target;\n        var key = e.key;\n        var selectionStart = el.selectionStart;\n        var selectionEnd = el.selectionEnd;\n        var value = el.value;\n        if (value === void 0) value = \"\";\n        // if user tries to delete partial prefix then ignore it\n        if ((key === \"Backspace\" || key === \"Delete\") && selectionEnd < prefix.length) {\n            e.preventDefault();\n            return;\n        }\n        // if multiple characters are selected and user hits backspace, no need to handle anything manually\n        if (selectionStart !== selectionEnd) {\n            onKeyDown(e);\n            return;\n        }\n        // if user hits backspace, while the cursor is before prefix, and the input has negation, remove the negation\n        if (key === \"Backspace\" && value[0] === \"-\" && selectionStart === prefix.length + 1 && allowNegative) {\n            // bring the cursor to after negation\n            setCaretPosition(el, 1);\n        }\n        // don't allow user to delete decimal separator when decimalScale and fixedDecimalScale is set\n        if (decimalScale && fixedDecimalScale) {\n            if (key === \"Backspace\" && value[selectionStart - 1] === decimalSeparator) {\n                setCaretPosition(el, selectionStart - 1);\n                e.preventDefault();\n            } else if (key === \"Delete\" && value[selectionStart] === decimalSeparator) {\n                e.preventDefault();\n            }\n        }\n        // if user presses the allowed decimal separator before the separator, move the cursor after the separator\n        if ((allowedDecimalSeparators === null || allowedDecimalSeparators === void 0 ? void 0 : allowedDecimalSeparators.includes(key)) && value[selectionStart] === decimalSeparator) {\n            setCaretPosition(el, selectionStart + 1);\n        }\n        var _thousandSeparator = thousandSeparator === true ? \",\" : thousandSeparator;\n        // move cursor when delete or backspace is pressed before/after thousand separator\n        if (key === \"Backspace\" && value[selectionStart - 1] === _thousandSeparator) {\n            setCaretPosition(el, selectionStart - 1);\n        }\n        if (key === \"Delete\" && value[selectionStart] === _thousandSeparator) {\n            setCaretPosition(el, selectionStart + 1);\n        }\n        onKeyDown(e);\n    };\n    var _onBlur = function(e) {\n        var _value = numAsString;\n        // if there no no numeric value, clear the input\n        if (!_value.match(/\\d/g)) {\n            _value = \"\";\n        }\n        // clear leading 0s\n        if (!allowLeadingZeros) {\n            _value = fixLeadingZero(_value);\n        }\n        // apply fixedDecimalScale on blur event\n        if (fixedDecimalScale && decimalScale) {\n            _value = roundToPrecision(_value, decimalScale, fixedDecimalScale);\n        }\n        if (_value !== numAsString) {\n            var formattedValue = format(_value, props);\n            _onValueChange({\n                formattedValue: formattedValue,\n                value: _value,\n                floatValue: parseFloat(_value)\n            }, {\n                event: e,\n                source: SourceType.event\n            });\n        }\n        onBlur(e);\n    };\n    var isValidInputCharacter = function(inputChar) {\n        if (inputChar === decimalSeparator) {\n            return true;\n        }\n        return charIsNumber(inputChar);\n    };\n    var isCharacterSame = function(ref) {\n        var currentValue = ref.currentValue;\n        var lastValue = ref.lastValue;\n        var formattedValue = ref.formattedValue;\n        var currentValueIndex = ref.currentValueIndex;\n        var formattedValueIndex = ref.formattedValueIndex;\n        var curChar = currentValue[currentValueIndex];\n        var newChar = formattedValue[formattedValueIndex];\n        /**\n         * NOTE: as thousand separator and allowedDecimalSeparators can be same, we need to check on\n         * typed range if we have typed any character from allowedDecimalSeparators, in that case we\n         * consider different characters like , and . same within the range of updated value.\n         */ var typedRange = findChangeRange(lastValue, currentValue);\n        var to = typedRange.to;\n        if (currentValueIndex >= to.start && currentValueIndex < to.end && allowedDecimalSeparators && allowedDecimalSeparators.includes(curChar) && newChar === decimalSeparator) {\n            return true;\n        }\n        return curChar === newChar;\n    };\n    return Object.assign(Object.assign({}, restProps), {\n        value: formattedValue,\n        valueIsNumericString: false,\n        isValidInputCharacter: isValidInputCharacter,\n        isCharacterSame: isCharacterSame,\n        onValueChange: _onValueChange,\n        format: _format,\n        removeFormatting: _removeFormatting,\n        getCaretBoundary: function(formattedValue) {\n            return getCaretBoundary(formattedValue, props);\n        },\n        onKeyDown: _onKeyDown,\n        onBlur: _onBlur\n    });\n}\nfunction NumericFormat(props) {\n    var numericFormatProps = useNumericFormat(props);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(NumberFormatBase, Object.assign({}, numericFormatProps));\n}\nfunction format$1(numStr, props) {\n    var format = props.format;\n    var allowEmptyFormatting = props.allowEmptyFormatting;\n    var mask = props.mask;\n    var patternChar = props.patternChar;\n    if (patternChar === void 0) patternChar = \"#\";\n    if (numStr === \"\" && !allowEmptyFormatting) {\n        return \"\";\n    }\n    var hashCount = 0;\n    var formattedNumberAry = format.split(\"\");\n    for(var i = 0, ln = format.length; i < ln; i++){\n        if (format[i] === patternChar) {\n            formattedNumberAry[i] = numStr[hashCount] || getMaskAtIndex(mask, hashCount);\n            hashCount += 1;\n        }\n    }\n    return formattedNumberAry.join(\"\");\n}\nfunction removeFormatting$1(value, changeMeta, props) {\n    if (changeMeta === void 0) changeMeta = getDefaultChangeMeta(value);\n    var format = props.format;\n    var patternChar = props.patternChar;\n    if (patternChar === void 0) patternChar = \"#\";\n    var from = changeMeta.from;\n    var to = changeMeta.to;\n    var lastValue = changeMeta.lastValue;\n    if (lastValue === void 0) lastValue = \"\";\n    var isNumericSlot = function(caretPos) {\n        return format[caretPos] === patternChar;\n    };\n    var removeFormatChar = function(string, startIndex) {\n        var str = \"\";\n        for(var i = 0; i < string.length; i++){\n            if (isNumericSlot(startIndex + i) && charIsNumber(string[i])) {\n                str += string[i];\n            }\n        }\n        return str;\n    };\n    var extractNumbers = function(str) {\n        return str.replace(/[^0-9]/g, \"\");\n    };\n    // if format doesn't have any number, remove all the non numeric characters\n    if (!format.match(/\\d/)) {\n        return extractNumbers(value);\n    }\n    /**\n     * if user paste the whole formatted text in an empty input or doing select all and paste, check if matches to the pattern\n     * and remove the format characters, if there is a mismatch on the pattern, do plane number extract\n     */ if ((lastValue === \"\" || from.end - from.start === lastValue.length) && value.length === format.length) {\n        var str = \"\";\n        for(var i = 0; i < value.length; i++){\n            if (isNumericSlot(i)) {\n                if (charIsNumber(value[i])) {\n                    str += value[i];\n                }\n            } else if (value[i] !== format[i]) {\n                // if there is a mismatch on the pattern, do plane number extract\n                return extractNumbers(value);\n            }\n        }\n        return str;\n    }\n    /**\n     * For partial change,\n     * where ever there is a change on the input, we can break the number in three parts\n     * 1st: left part which is unchanged\n     * 2nd: middle part which is changed\n     * 3rd: right part which is unchanged\n     *\n     * The first and third section will be same as last value, only the middle part will change\n     * We can consider on the change part all the new characters are non format characters.\n     * And on the first and last section it can have partial format characters.\n     *\n     * We pick first and last section from the lastValue (as that has 1-1 mapping with format)\n     * and middle one from the update value.\n     */ var firstSection = lastValue.substring(0, from.start);\n    var middleSection = value.substring(to.start, to.end);\n    var lastSection = lastValue.substring(from.end);\n    return \"\" + removeFormatChar(firstSection, 0) + extractNumbers(middleSection) + removeFormatChar(lastSection, from.end);\n}\nfunction getCaretBoundary$1(formattedValue, props) {\n    var format = props.format;\n    var mask = props.mask;\n    var patternChar = props.patternChar;\n    if (patternChar === void 0) patternChar = \"#\";\n    var boundaryAry = Array.from({\n        length: formattedValue.length + 1\n    }).map(function() {\n        return true;\n    });\n    var hashCount = 0;\n    var firstEmptySlot = -1;\n    var maskAndIndexMap = {};\n    format.split(\"\").forEach(function(char, index) {\n        var maskAtIndex = undefined;\n        if (char === patternChar) {\n            hashCount++;\n            maskAtIndex = getMaskAtIndex(mask, hashCount - 1);\n            if (firstEmptySlot === -1 && formattedValue[index] === maskAtIndex) {\n                firstEmptySlot = index;\n            }\n        }\n        maskAndIndexMap[index] = maskAtIndex;\n    });\n    var isPosAllowed = function(pos) {\n        // the position is allowed if the position is not masked and valid number area\n        return format[pos] === patternChar && formattedValue[pos] !== maskAndIndexMap[pos];\n    };\n    for(var i = 0, ln = boundaryAry.length; i < ln; i++){\n        // consider caret to be in boundary if it is before or after numeric value\n        // Note: on pattern based format its denoted by patternCharacter\n        // we should also allow user to put cursor on first empty slot\n        boundaryAry[i] = i === firstEmptySlot || isPosAllowed(i) || isPosAllowed(i - 1);\n    }\n    // the first patternChar position is always allowed\n    boundaryAry[format.indexOf(patternChar)] = true;\n    return boundaryAry;\n}\nfunction validateProps(props) {\n    var mask = props.mask;\n    if (mask) {\n        var maskAsStr = mask === \"string\" ? mask : mask.toString();\n        if (maskAsStr.match(/\\d/g)) {\n            throw new Error(\"Mask \" + mask + \" should not contain numeric character;\");\n        }\n    }\n}\nfunction isNumericString$1(val, format) {\n    //we can treat empty string as numeric string\n    if (val === \"\") {\n        return true;\n    }\n    return !(format === null || format === void 0 ? void 0 : format.match(/\\d/)) && typeof val === \"string\" && (!!val.match(/^\\d+$/) || val === \"\");\n}\nfunction usePatternFormat(props) {\n    var mask = props.mask;\n    var allowEmptyFormatting = props.allowEmptyFormatting;\n    var formatProp = props.format;\n    var inputMode = props.inputMode;\n    if (inputMode === void 0) inputMode = \"numeric\";\n    var onKeyDown = props.onKeyDown;\n    if (onKeyDown === void 0) onKeyDown = noop;\n    var patternChar = props.patternChar;\n    if (patternChar === void 0) patternChar = \"#\";\n    var value = props.value;\n    var defaultValue = props.defaultValue;\n    var valueIsNumericString = props.valueIsNumericString;\n    var restProps = __rest(props, [\n        \"mask\",\n        \"allowEmptyFormatting\",\n        \"format\",\n        \"inputMode\",\n        \"onKeyDown\",\n        \"patternChar\",\n        \"value\",\n        \"defaultValue\",\n        \"valueIsNumericString\"\n    ]);\n    // validate props\n    validateProps(props);\n    var _getCaretBoundary = function(formattedValue) {\n        return getCaretBoundary$1(formattedValue, props);\n    };\n    var _onKeyDown = function(e) {\n        var key = e.key;\n        var el = e.target;\n        var selectionStart = el.selectionStart;\n        var selectionEnd = el.selectionEnd;\n        var value = el.value;\n        // if multiple characters are selected and user hits backspace, no need to handle anything manually\n        if (selectionStart !== selectionEnd) {\n            onKeyDown(e);\n            return;\n        }\n        // bring the cursor to closest numeric section\n        var caretPos = selectionStart;\n        // if backspace is pressed after the format characters, bring it to numeric section\n        // if delete is pressed before the format characters, bring it to numeric section\n        if (key === \"Backspace\" || key === \"Delete\") {\n            var direction = \"right\";\n            if (key === \"Backspace\") {\n                while(caretPos > 0 && formatProp[caretPos - 1] !== patternChar){\n                    caretPos--;\n                }\n                direction = \"left\";\n            } else {\n                var formatLn = formatProp.length;\n                while(caretPos < formatLn && formatProp[caretPos] !== patternChar){\n                    caretPos++;\n                }\n                direction = \"right\";\n            }\n            caretPos = getCaretPosInBoundary(value, caretPos, _getCaretBoundary(value), direction);\n        } else if (formatProp[caretPos] !== patternChar && key !== \"ArrowLeft\" && key !== \"ArrowRight\") {\n            // if user is typing on format character position, bring user to next allowed caret position\n            caretPos = getCaretPosInBoundary(value, caretPos + 1, _getCaretBoundary(value), \"right\");\n        }\n        // if we changing caret position, set the caret position\n        if (caretPos !== selectionStart) {\n            setCaretPosition(el, caretPos);\n        }\n        onKeyDown(e);\n    };\n    // try to figure out isValueNumericString based on format prop and value\n    var _value = isNil(value) ? defaultValue : value;\n    var isValueNumericString = valueIsNumericString !== null && valueIsNumericString !== void 0 ? valueIsNumericString : isNumericString$1(_value, formatProp);\n    var _props = Object.assign(Object.assign({}, props), {\n        valueIsNumericString: isValueNumericString\n    });\n    return Object.assign(Object.assign({}, restProps), {\n        value: value,\n        defaultValue: defaultValue,\n        valueIsNumericString: isValueNumericString,\n        inputMode: inputMode,\n        format: function(numStr) {\n            return format$1(numStr, _props);\n        },\n        removeFormatting: function(inputValue, changeMeta) {\n            return removeFormatting$1(inputValue, changeMeta, _props);\n        },\n        getCaretBoundary: _getCaretBoundary,\n        onKeyDown: _onKeyDown\n    });\n}\nfunction PatternFormat(props) {\n    var patternFormatProps = usePatternFormat(props);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(NumberFormatBase, Object.assign({}, patternFormatProps));\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtbnVtYmVyLWZvcm1hdC9kaXN0L3JlYWN0LW51bWJlci1mb3JtYXQuZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7OztDQUtDLEdBRW9GO0FBRXJGOzs7Ozs7Ozs7Ozs7OzhFQWE4RSxHQUU5RSxTQUFTTSxPQUFPQyxDQUFDLEVBQUVDLENBQUM7SUFDaEIsSUFBSUMsSUFBSSxDQUFDO0lBQ1QsSUFBSyxJQUFJQyxLQUFLSCxFQUFHO1FBQUUsSUFBSUksT0FBT0MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ1AsR0FBR0csTUFBTUYsRUFBRU8sT0FBTyxDQUFDTCxLQUFLLEdBQ2hGO1lBQUVELENBQUMsQ0FBQ0MsRUFBRSxHQUFHSCxDQUFDLENBQUNHLEVBQUU7UUFBRTtJQUFFO0lBQ3JCLElBQUlILEtBQUssUUFBUSxPQUFPSSxPQUFPSyxxQkFBcUIsS0FBSyxZQUNyRDtRQUFFLElBQUssSUFBSUMsSUFBSSxHQUFHUCxJQUFJQyxPQUFPSyxxQkFBcUIsQ0FBQ1QsSUFBSVUsSUFBSVAsRUFBRVEsTUFBTSxFQUFFRCxJQUFLO1lBQ3RFLElBQUlULEVBQUVPLE9BQU8sQ0FBQ0wsQ0FBQyxDQUFDTyxFQUFFLElBQUksS0FBS04sT0FBT0MsU0FBUyxDQUFDTyxvQkFBb0IsQ0FBQ0wsSUFBSSxDQUFDUCxHQUFHRyxDQUFDLENBQUNPLEVBQUUsR0FDekU7Z0JBQUVSLENBQUMsQ0FBQ0MsQ0FBQyxDQUFDTyxFQUFFLENBQUMsR0FBR1YsQ0FBQyxDQUFDRyxDQUFDLENBQUNPLEVBQUUsQ0FBQztZQUFFO1FBQzdCO0lBQUU7SUFDTixPQUFPUjtBQUNYO0FBRUEsSUFBSVc7QUFDSCxVQUFVQSxVQUFVO0lBQ2pCQSxVQUFVLENBQUMsUUFBUSxHQUFHO0lBQ3RCQSxVQUFVLENBQUMsUUFBUSxHQUFHO0FBQzFCLEdBQUdBLGNBQWVBLENBQUFBLGFBQWEsQ0FBQztBQUVoQyxzQkFBc0I7QUFDdEIs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LFlBQVlZLFlBQVl1RztRQUFTO1FBQUd4SSxrQkFBa0JxSTtRQUFtQjFJLFdBQVcrQztJQUFXO0FBQ3JWO0FBQ0EsU0FBUytGLGNBQWN0SixLQUFLO0lBQ3hCLElBQUl1SixxQkFBcUJQLGlCQUFpQmhKO0lBQzFDLHFCQUFPbk0sMERBQW1CLENBQUNrTSxrQkFBa0J2TCxPQUFPdU8sTUFBTSxDQUFDLENBQUMsR0FBR3dHO0FBQ25FO0FBRXdVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbm94Zm9saW8vLi9ub2RlX21vZHVsZXMvcmVhY3QtbnVtYmVyLWZvcm1hdC9kaXN0L3JlYWN0LW51bWJlci1mb3JtYXQuZXMuanM/MzQ3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHJlYWN0LW51bWJlci1mb3JtYXQgLSA1LjQuMFxuICogQXV0aG9yIDogU3VkaGFuc2h1IFlhZGF2XG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYsIDIwMjQgdG8gU3VkaGFuc2h1IFlhZGF2LCByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcy15YWRhdi9yZWFjdC1udW1iZXItZm9ybWF0XG4gKi9cblxuaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCB1c2VNZW1vLCB1c2VSZWYsIHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB7IHRbcF0gPSBzW3BdOyB9IH1cclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICB7IGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgeyB0W3BbaV1dID0gc1twW2ldXTsgfVxyXG4gICAgICAgIH0gfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cblxudmFyIFNvdXJjZVR5cGU7XG4oZnVuY3Rpb24gKFNvdXJjZVR5cGUpIHtcbiAgICBTb3VyY2VUeXBlW1wiZXZlbnRcIl0gPSBcImV2ZW50XCI7XG4gICAgU291cmNlVHlwZVtcInByb3BzXCJdID0gXCJwcm9wXCI7XG59KShTb3VyY2VUeXBlIHx8IChTb3VyY2VUeXBlID0ge30pKTtcblxuLy8gYmFzaWMgbm9vcCBmdW5jdGlvblxuZnVuY3Rpb24gbm9vcCgpIHsgfVxuZnVuY3Rpb24gbWVtb2l6ZU9uY2UoY2IpIHtcbiAgICB2YXIgbGFzdEFyZ3M7XG4gICAgdmFyIGxhc3RWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIGlmIChsYXN0QXJncyAmJlxuICAgICAgICAgICAgYXJncy5sZW5ndGggPT09IGxhc3RBcmdzLmxlbmd0aCAmJlxuICAgICAgICAgICAgYXJncy5ldmVyeShmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7IHJldHVybiB2YWx1ZSA9PT0gbGFzdEFyZ3NbaW5kZXhdOyB9KSkge1xuICAgICAgICAgICAgcmV0dXJuIGxhc3RWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0QXJncyA9IGFyZ3M7XG4gICAgICAgIGxhc3RWYWx1ZSA9IGNiLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgICAgIHJldHVybiBsYXN0VmFsdWU7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNoYXJJc051bWJlcihjaGFyKSB7XG4gICAgcmV0dXJuICEhKGNoYXIgfHwgJycpLm1hdGNoKC9cXGQvKTtcbn1cbmZ1bmN0aW9uIGlzTmlsKHZhbCkge1xuICAgIHJldHVybiB2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBpc05hblZhbHVlKHZhbCkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWwpO1xufVxuZnVuY3Rpb24gaXNOb3RWYWxpZFZhbHVlKHZhbCkge1xuICAgIHJldHVybiBpc05pbCh2YWwpIHx8IGlzTmFuVmFsdWUodmFsKSB8fCAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgIWlzRmluaXRlKHZhbCkpO1xufVxuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvWy1bXFxdL3t9KCkqKz8uXFxcXF4kfF0vZywgJ1xcXFwkJicpO1xufVxuZnVuY3Rpb24gZ2V0VGhvdXNhbmRzR3JvdXBSZWdleCh0aG91c2FuZHNHcm91cFN0eWxlKSB7XG4gICAgc3dpdGNoICh0aG91c2FuZHNHcm91cFN0eWxlKSB7XG4gICAgICAgIGNhc2UgJ2xha2gnOlxuICAgICAgICAgICAgcmV0dXJuIC8oXFxkKz8pKD89KFxcZFxcZCkrKFxcZCkoPyFcXGQpKShcXC5cXGQrKT8vZztcbiAgICAgICAgY2FzZSAnd2FuJzpcbiAgICAgICAgICAgIHJldHVybiAvKFxcZCkoPz0oXFxkezR9KSsoPyFcXGQpKS9nO1xuICAgICAgICBjYXNlICd0aG91c2FuZCc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gLyhcXGQpKD89KFxcZHszfSkrKD8hXFxkKSkvZztcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseVRob3VzYW5kU2VwYXJhdG9yKHN0ciwgdGhvdXNhbmRTZXBhcmF0b3IsIHRob3VzYW5kc0dyb3VwU3R5bGUpIHtcbiAgICB2YXIgdGhvdXNhbmRzR3JvdXBSZWdleCA9IGdldFRob3VzYW5kc0dyb3VwUmVnZXgodGhvdXNhbmRzR3JvdXBTdHlsZSk7XG4gICAgdmFyIGluZGV4ID0gc3RyLnNlYXJjaCgvWzEtOV0vKTtcbiAgICBpbmRleCA9IGluZGV4ID09PSAtMSA/IHN0ci5sZW5ndGggOiBpbmRleDtcbiAgICByZXR1cm4gKHN0ci5zdWJzdHJpbmcoMCwgaW5kZXgpICtcbiAgICAgICAgc3RyLnN1YnN0cmluZyhpbmRleCwgc3RyLmxlbmd0aCkucmVwbGFjZSh0aG91c2FuZHNHcm91cFJlZ2V4LCAnJDEnICsgdGhvdXNhbmRTZXBhcmF0b3IpKTtcbn1cbmZ1bmN0aW9uIHVzZVBlcnNpc3RlbnRDYWxsYmFjayhjYikge1xuICAgIHZhciBjYWxsYmFja1JlZiA9IHVzZVJlZihjYik7XG4gICAgLy8ga2VlcCB0aGUgY2FsbGJhY2sgcmVmIHVwdG8gZGF0ZVxuICAgIGNhbGxiYWNrUmVmLmN1cnJlbnQgPSBjYjtcbiAgICAvKipcbiAgICAgKiBpbml0aWFsaXplIGEgcGVyc2lzdGVudCBjYWxsYmFjayB3aGljaCBuZXZlciBjaGFuZ2VzXG4gICAgICogdGhyb3VnaCBvdXQgdGhlIGNvbXBvbmVudCBsaWZlY3ljbGVcbiAgICAgKi9cbiAgICB2YXIgcGVyc2lzdGVudENiUmVmID0gdXNlUmVmKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICByZXR1cm4gY2FsbGJhY2tSZWYuY3VycmVudC5hcHBseShjYWxsYmFja1JlZiwgYXJncyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHBlcnNpc3RlbnRDYlJlZi5jdXJyZW50O1xufVxuLy9zcGlsdCBhIGZsb2F0IG51bWJlciBpbnRvIGRpZmZlcmVudCBwYXJ0cyBiZWZvcmVEZWNpbWFsLCBhZnRlckRlY2ltYWwsIGFuZCBuZWdhdGlvblxuZnVuY3Rpb24gc3BsaXREZWNpbWFsKG51bVN0ciwgYWxsb3dOZWdhdGl2ZSkge1xuICAgIGlmICggYWxsb3dOZWdhdGl2ZSA9PT0gdm9pZCAwICkgYWxsb3dOZWdhdGl2ZSA9IHRydWU7XG5cbiAgICB2YXIgaGFzTmVnYXRpb24gPSBudW1TdHJbMF0gPT09ICctJztcbiAgICB2YXIgYWRkTmVnYXRpb24gPSBoYXNOZWdhdGlvbiAmJiBhbGxvd05lZ2F0aXZlO1xuICAgIG51bVN0ciA9IG51bVN0ci5yZXBsYWNlKCctJywgJycpO1xuICAgIHZhciBwYXJ0cyA9IG51bVN0ci5zcGxpdCgnLicpO1xuICAgIHZhciBiZWZvcmVEZWNpbWFsID0gcGFydHNbMF07XG4gICAgdmFyIGFmdGVyRGVjaW1hbCA9IHBhcnRzWzFdIHx8ICcnO1xuICAgIHJldHVybiB7XG4gICAgICAgIGJlZm9yZURlY2ltYWw6IGJlZm9yZURlY2ltYWwsXG4gICAgICAgIGFmdGVyRGVjaW1hbDogYWZ0ZXJEZWNpbWFsLFxuICAgICAgICBoYXNOZWdhdGlvbjogaGFzTmVnYXRpb24sXG4gICAgICAgIGFkZE5lZ2F0aW9uOiBhZGROZWdhdGlvbixcbiAgICB9O1xufVxuZnVuY3Rpb24gZml4TGVhZGluZ1plcm8obnVtU3RyKSB7XG4gICAgaWYgKCFudW1TdHIpXG4gICAgICAgIHsgcmV0dXJuIG51bVN0cjsgfVxuICAgIHZhciBpc05lZ2F0aXZlID0gbnVtU3RyWzBdID09PSAnLSc7XG4gICAgaWYgKGlzTmVnYXRpdmUpXG4gICAgICAgIHsgbnVtU3RyID0gbnVtU3RyLnN1YnN0cmluZygxLCBudW1TdHIubGVuZ3RoKTsgfVxuICAgIHZhciBwYXJ0cyA9IG51bVN0ci5zcGxpdCgnLicpO1xuICAgIHZhciBiZWZvcmVEZWNpbWFsID0gcGFydHNbMF0ucmVwbGFjZSgvXjArLywgJycpIHx8ICcwJztcbiAgICB2YXIgYWZ0ZXJEZWNpbWFsID0gcGFydHNbMV0gfHwgJyc7XG4gICAgcmV0dXJuIChcIlwiICsgKGlzTmVnYXRpdmUgPyAnLScgOiAnJykgKyBiZWZvcmVEZWNpbWFsICsgKGFmdGVyRGVjaW1hbCA/IChcIi5cIiArIGFmdGVyRGVjaW1hbCkgOiAnJykpO1xufVxuLyoqXG4gKiBsaW1pdCBkZWNpbWFsIG51bWJlcnMgdG8gZ2l2ZW4gc2NhbGVcbiAqIE5vdCB1c2VkIC5maXhlZFRvIGJlY2F1c2UgdGhhdCB3aWxsIGJyZWFrIHdpdGggYmlnIG51bWJlcnNcbiAqL1xuZnVuY3Rpb24gbGltaXRUb1NjYWxlKG51bVN0ciwgc2NhbGUsIGZpeGVkRGVjaW1hbFNjYWxlKSB7XG4gICAgdmFyIHN0ciA9ICcnO1xuICAgIHZhciBmaWxsZXIgPSBmaXhlZERlY2ltYWxTY2FsZSA/ICcwJyA6ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHNjYWxlIC0gMTsgaSsrKSB7XG4gICAgICAgIHN0ciArPSBudW1TdHJbaV0gfHwgZmlsbGVyO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gcmVwZWF0KHN0ciwgY291bnQpIHtcbiAgICByZXR1cm4gQXJyYXkoY291bnQgKyAxKS5qb2luKHN0cik7XG59XG5mdW5jdGlvbiB0b051bWVyaWNTdHJpbmcobnVtKSB7XG4gICAgdmFyIF9udW0gPSBudW0gKyAnJzsgLy8gdHlwZWNhc3QgbnVtYmVyIHRvIHN0cmluZ1xuICAgIC8vIHN0b3JlIHRoZSBzaWduIGFuZCByZW1vdmUgaXQgZnJvbSB0aGUgbnVtYmVyLlxuICAgIHZhciBzaWduID0gX251bVswXSA9PT0gJy0nID8gJy0nIDogJyc7XG4gICAgaWYgKHNpZ24pXG4gICAgICAgIHsgX251bSA9IF9udW0uc3Vic3RyaW5nKDEpOyB9XG4gICAgLy8gc3BsaXQgdGhlIG51bWJlciBpbnRvIGNvZmZpY2llbnQgYW5kIGV4cG9uZW50XG4gICAgdmFyIHJlZiA9IF9udW0uc3BsaXQoL1tlRV0vZyk7XG4gICAgdmFyIGNvZWZmaWNpZW50ID0gcmVmWzBdO1xuICAgIHZhciBleHBvbmVudCA9IHJlZlsxXTtcbiAgICAvLyBjb3ZlcnQgZXhwb25lbnQgdG8gbnVtYmVyO1xuICAgIGV4cG9uZW50ID0gTnVtYmVyKGV4cG9uZW50KTtcbiAgICAvLyBpZiB0aGVyZSBpcyBubyBleHBvbmVudCBwYXJ0IG9yIGl0cyAwLCByZXR1cm4gdGhlIGNvZmZpZWNpZW50IHdpdGggc2lnblxuICAgIGlmICghZXhwb25lbnQpXG4gICAgICAgIHsgcmV0dXJuIHNpZ24gKyBjb2VmZmljaWVudDsgfVxuICAgIGNvZWZmaWNpZW50ID0gY29lZmZpY2llbnQucmVwbGFjZSgnLicsICcnKTtcbiAgICAvKipcbiAgICAgKiBmb3Igc2NpZW50aWZpYyBub3RhdGlvbiB0aGUgY3VycmVudCBkZWNpbWFsIGluZGV4IHdpbGwgYmUgYWZ0ZXIgZmlyc3QgbnVtYmVyIChpbmRleCAwKVxuICAgICAqIFNvIGVmZmVjdGl2ZSBkZWNpbWFsIGluZGV4IHdpbGwgYWx3YXlzIGJlIDEgKyBleHBvbmVudCB2YWx1ZVxuICAgICAqL1xuICAgIHZhciBkZWNpbWFsSW5kZXggPSAxICsgZXhwb25lbnQ7XG4gICAgdmFyIGNvZmZpZWNpZW50TG4gPSBjb2VmZmljaWVudC5sZW5ndGg7XG4gICAgaWYgKGRlY2ltYWxJbmRleCA8IDApIHtcbiAgICAgICAgLy8gaWYgZGVjaW1hbCBpbmRleCBpcyBsZXNzIHRoZW4gMCBhZGQgcHJlY2VkaW5nIDBzXG4gICAgICAgIC8vIGFkZCAxIGFzIGpvaW4gd2lsbCBoYXZlXG4gICAgICAgIGNvZWZmaWNpZW50ID0gJzAuJyArIHJlcGVhdCgnMCcsIE1hdGguYWJzKGRlY2ltYWxJbmRleCkpICsgY29lZmZpY2llbnQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRlY2ltYWxJbmRleCA+PSBjb2ZmaWVjaWVudExuKSB7XG4gICAgICAgIC8vIGlmIGRlY2ltYWwgaW5kZXggaXMgbGVzcyB0aGVuIDAgYWRkIGxlYWRpbmcgMHNcbiAgICAgICAgY29lZmZpY2llbnQgPSBjb2VmZmljaWVudCArIHJlcGVhdCgnMCcsIGRlY2ltYWxJbmRleCAtIGNvZmZpZWNpZW50TG4pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gZWxzZSBhZGQgZGVjaW1hbCBwb2ludCBhdCBwcm9wZXIgaW5kZXhcbiAgICAgICAgY29lZmZpY2llbnQgPVxuICAgICAgICAgICAgKGNvZWZmaWNpZW50LnN1YnN0cmluZygwLCBkZWNpbWFsSW5kZXgpIHx8ICcwJykgKyAnLicgKyBjb2VmZmljaWVudC5zdWJzdHJpbmcoZGVjaW1hbEluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHNpZ24gKyBjb2VmZmljaWVudDtcbn1cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgcmVxdWlyZWQgdG8gcm91bmQgcHJvcCB2YWx1ZSB0byBnaXZlbiBzY2FsZS5cbiAqIE5vdCB1c2VkIC5yb3VuZCBvciAuZml4ZWRUbyBiZWNhdXNlIHRoYXQgd2lsbCBicmVhayB3aXRoIGJpZyBudW1iZXJzXG4gKi9cbmZ1bmN0aW9uIHJvdW5kVG9QcmVjaXNpb24obnVtU3RyLCBzY2FsZSwgZml4ZWREZWNpbWFsU2NhbGUpIHtcbiAgICAvL2lmIG51bWJlciBpcyBlbXB0eSBkb24ndCBkbyBhbnl0aGluZyByZXR1cm4gZW1wdHkgc3RyaW5nXG4gICAgaWYgKFsnJywgJy0nXS5pbmRleE9mKG51bVN0cikgIT09IC0xKVxuICAgICAgICB7IHJldHVybiBudW1TdHI7IH1cbiAgICB2YXIgc2hvdWxkSGF2ZURlY2ltYWxTZXBhcmF0b3IgPSAobnVtU3RyLmluZGV4T2YoJy4nKSAhPT0gLTEgfHwgZml4ZWREZWNpbWFsU2NhbGUpICYmIHNjYWxlO1xuICAgIHZhciByZWYgPSBzcGxpdERlY2ltYWwobnVtU3RyKTtcbiAgICB2YXIgYmVmb3JlRGVjaW1hbCA9IHJlZi5iZWZvcmVEZWNpbWFsO1xuICAgIHZhciBhZnRlckRlY2ltYWwgPSByZWYuYWZ0ZXJEZWNpbWFsO1xuICAgIHZhciBoYXNOZWdhdGlvbiA9IHJlZi5oYXNOZWdhdGlvbjtcbiAgICB2YXIgZmxvYXRWYWx1ZSA9IHBhcnNlRmxvYXQoKFwiMC5cIiArIChhZnRlckRlY2ltYWwgfHwgJzAnKSkpO1xuICAgIHZhciBmbG9hdFZhbHVlU3RyID0gYWZ0ZXJEZWNpbWFsLmxlbmd0aCA8PSBzY2FsZSA/IChcIjAuXCIgKyBhZnRlckRlY2ltYWwpIDogZmxvYXRWYWx1ZS50b0ZpeGVkKHNjYWxlKTtcbiAgICB2YXIgcm91bmRlZERlY2ltYWxQYXJ0cyA9IGZsb2F0VmFsdWVTdHIuc3BsaXQoJy4nKTtcbiAgICB2YXIgaW50UGFydCA9IGJlZm9yZURlY2ltYWw7XG4gICAgLy8gaWYgd2UgaGF2ZSBjYXJ5IG92ZXIgZnJvbSByb3VuZGluZyBkZWNpbWFsIHBhcnQsIGFkZCB0aGF0IG9uIGJlZm9yZSBkZWNpbWFsXG4gICAgaWYgKGJlZm9yZURlY2ltYWwgJiYgTnVtYmVyKHJvdW5kZWREZWNpbWFsUGFydHNbMF0pKSB7XG4gICAgICAgIGludFBhcnQgPSBiZWZvcmVEZWNpbWFsXG4gICAgICAgICAgICAuc3BsaXQoJycpXG4gICAgICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChyb3VuZGVkU3RyLCBjdXJyZW50LCBpZHgpIHtcbiAgICAgICAgICAgIGlmIChyb3VuZGVkU3RyLmxlbmd0aCA+IGlkeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoKE51bWJlcihyb3VuZGVkU3RyWzBdKSArIE51bWJlcihjdXJyZW50KSkudG9TdHJpbmcoKSArXG4gICAgICAgICAgICAgICAgICAgIHJvdW5kZWRTdHIuc3Vic3RyaW5nKDEsIHJvdW5kZWRTdHIubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudCArIHJvdW5kZWRTdHI7XG4gICAgICAgIH0sIHJvdW5kZWREZWNpbWFsUGFydHNbMF0pO1xuICAgIH1cbiAgICB2YXIgZGVjaW1hbFBhcnQgPSBsaW1pdFRvU2NhbGUocm91bmRlZERlY2ltYWxQYXJ0c1sxXSB8fCAnJywgc2NhbGUsIGZpeGVkRGVjaW1hbFNjYWxlKTtcbiAgICB2YXIgbmVnYXRpb24gPSBoYXNOZWdhdGlvbiA/ICctJyA6ICcnO1xuICAgIHZhciBkZWNpbWFsU2VwYXJhdG9yID0gc2hvdWxkSGF2ZURlY2ltYWxTZXBhcmF0b3IgPyAnLicgOiAnJztcbiAgICByZXR1cm4gKFwiXCIgKyBuZWdhdGlvbiArIGludFBhcnQgKyBkZWNpbWFsU2VwYXJhdG9yICsgZGVjaW1hbFBhcnQpO1xufVxuLyoqIHNldCB0aGUgY2FyZXQgcG9zaXRvbiBpbiBhbiBpbnB1dCBmaWVsZCAqKi9cbmZ1bmN0aW9uIHNldENhcmV0UG9zaXRpb24oZWwsIGNhcmV0UG9zKSB7XG4gICAgZWwudmFsdWUgPSBlbC52YWx1ZTtcbiAgICAvLyBeIHRoaXMgaXMgdXNlZCB0byBub3Qgb25seSBnZXQgJ2ZvY3VzJywgYnV0XG4gICAgLy8gdG8gbWFrZSBzdXJlIHdlIGRvbid0IGhhdmUgaXQgZXZlcnl0aGluZyAtc2VsZWN0ZWQtXG4gICAgLy8gKGl0IGNhdXNlcyBhbiBpc3N1ZSBpbiBjaHJvbWUsIGFuZCBoYXZpbmcgaXQgZG9lc24ndCBodXJ0IGFueSBvdGhlciBicm93c2VyKVxuICAgIGlmIChlbCAhPT0gbnVsbCkge1xuICAgICAgICAvKiBAdHMtaWdub3JlICovXG4gICAgICAgIGlmIChlbC5jcmVhdGVUZXh0UmFuZ2UpIHtcbiAgICAgICAgICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICAgICAgICAgIHZhciByYW5nZSA9IGVsLmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgICAgICAgICAgcmFuZ2UubW92ZSgnY2hhcmFjdGVyJywgY2FyZXRQb3MpO1xuICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyAoZWwuc2VsZWN0aW9uU3RhcnQgPT09IDAgYWRkZWQgZm9yIEZpcmVmb3ggYnVnKVxuICAgICAgICBpZiAoZWwuc2VsZWN0aW9uU3RhcnQgfHwgZWwuc2VsZWN0aW9uU3RhcnQgPT09IDApIHtcbiAgICAgICAgICAgIGVsLmZvY3VzKCk7XG4gICAgICAgICAgICBlbC5zZXRTZWxlY3Rpb25SYW5nZShjYXJldFBvcywgY2FyZXRQb3MpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmFpbCBjaXR5LCBmb3J0dW5hdGVseSB0aGlzIG5ldmVyIGhhcHBlbnMgKGFzIGZhciBhcyBJJ3ZlIHRlc3RlZCkgOilcbiAgICAgICAgZWwuZm9jdXMoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogVE9ETzogcmVtb3ZlIGRlcGVuZGVuY3kgb2YgZmluZENoYW5nZVJhbmdlLCBmaW5kQ2hhbmdlZFJhbmdlRnJvbUNhcmV0UG9zaXRpb25zIGlzIGJldHRlciB3YXkgdG8gZmluZCB3aGF0IGlzIGNoYW5nZWRcbiAqIGN1cnJlbnRseSB0aGlzIGlzIG1vc3RseSByZXF1aXJlZCBieSB0ZXN0IGFuZCBpc0NoYXJhY3RlclNhbWUgdXRpbFxuICogR2l2ZW4gcHJldmlvdXMgdmFsdWUgYW5kIG5ld1ZhbHVlIGl0IHJldHVybnMgdGhlIGluZGV4XG4gKiBzdGFydCAtIGVuZCB0byB3aGljaCB2YWx1ZXMgaGF2ZSBjaGFuZ2VkLlxuICogVGhpcyBmdW5jdGlvbiBtYWtlcyBhc3N1bXB0aW9uIGFib3V0IG9ubHkgY29uc2VjdXRpdmVcbiAqIGNoYXJhY3RlcnMgYXJlIGNoYW5nZWQgd2hpY2ggaXMgY29ycmVjdCBhc3N1bXB0aW9uIGZvciBjYXJldCBpbnB1dC5cbiAqL1xudmFyIGZpbmRDaGFuZ2VSYW5nZSA9IG1lbW9pemVPbmNlKGZ1bmN0aW9uIChwcmV2VmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgdmFyIGkgPSAwLCBqID0gMDtcbiAgICB2YXIgcHJldkxlbmd0aCA9IHByZXZWYWx1ZS5sZW5ndGg7XG4gICAgdmFyIG5ld0xlbmd0aCA9IG5ld1ZhbHVlLmxlbmd0aDtcbiAgICB3aGlsZSAocHJldlZhbHVlW2ldID09PSBuZXdWYWx1ZVtpXSAmJiBpIDwgcHJldkxlbmd0aClcbiAgICAgICAgeyBpKys7IH1cbiAgICAvL2NoZWNrIHdoYXQgaGFzIGJlZW4gY2hhbmdlZCBmcm9tIGxhc3RcbiAgICB3aGlsZSAocHJldlZhbHVlW3ByZXZMZW5ndGggLSAxIC0gal0gPT09IG5ld1ZhbHVlW25ld0xlbmd0aCAtIDEgLSBqXSAmJlxuICAgICAgICBuZXdMZW5ndGggLSBqID4gaSAmJlxuICAgICAgICBwcmV2TGVuZ3RoIC0gaiA+IGkpIHtcbiAgICAgICAgaisrO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBmcm9tOiB7IHN0YXJ0OiBpLCBlbmQ6IHByZXZMZW5ndGggLSBqIH0sXG4gICAgICAgIHRvOiB7IHN0YXJ0OiBpLCBlbmQ6IG5ld0xlbmd0aCAtIGogfSxcbiAgICB9O1xufSk7XG52YXIgZmluZENoYW5nZWRSYW5nZUZyb21DYXJldFBvc2l0aW9ucyA9IGZ1bmN0aW9uIChsYXN0Q2FyZXRQb3NpdGlvbnMsIGN1cnJlbnRDYXJldFBvc2l0aW9uKSB7XG4gICAgdmFyIHN0YXJ0UG9zaXRpb24gPSBNYXRoLm1pbihsYXN0Q2FyZXRQb3NpdGlvbnMuc2VsZWN0aW9uU3RhcnQsIGN1cnJlbnRDYXJldFBvc2l0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBmcm9tOiB7IHN0YXJ0OiBzdGFydFBvc2l0aW9uLCBlbmQ6IGxhc3RDYXJldFBvc2l0aW9ucy5zZWxlY3Rpb25FbmQgfSxcbiAgICAgICAgdG86IHsgc3RhcnQ6IHN0YXJ0UG9zaXRpb24sIGVuZDogY3VycmVudENhcmV0UG9zaXRpb24gfSxcbiAgICB9O1xufTtcbi8qXG4gIFJldHVybnMgYSBudW1iZXIgd2hvc2UgdmFsdWUgaXMgbGltaXRlZCB0byB0aGUgZ2l2ZW4gcmFuZ2VcbiovXG5mdW5jdGlvbiBjbGFtcChudW0sIG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG51bSwgbWluKSwgbWF4KTtcbn1cbmZ1bmN0aW9uIGdlSW5wdXRDYXJldFBvc2l0aW9uKGVsKSB7XG4gICAgLypNYXggb2Ygc2VsZWN0aW9uU3RhcnQgYW5kIHNlbGVjdGlvbkVuZCBpcyB0YWtlbiBmb3IgdGhlIHBhdGNoIG9mIHBpeGVsIGFuZCBvdGhlciBtb2JpbGUgZGV2aWNlIGNhcmV0IGJ1ZyovXG4gICAgcmV0dXJuIE1hdGgubWF4KGVsLnNlbGVjdGlvblN0YXJ0LCBlbC5zZWxlY3Rpb25FbmQpO1xufVxuZnVuY3Rpb24gYWRkSW5wdXRNb2RlKCkge1xuICAgIHJldHVybiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgIShuYXZpZ2F0b3IucGxhdGZvcm0gJiYgL2lQaG9uZXxpUG9kLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSkpKTtcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRDaGFuZ2VNZXRhKHZhbHVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbToge1xuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBlbmQ6IDAsXG4gICAgICAgIH0sXG4gICAgICAgIHRvOiB7XG4gICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgIGVuZDogdmFsdWUubGVuZ3RoLFxuICAgICAgICB9LFxuICAgICAgICBsYXN0VmFsdWU6ICcnLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRNYXNrQXRJbmRleChtYXNrLCBpbmRleCkge1xuICAgIGlmICggbWFzayA9PT0gdm9pZCAwICkgbWFzayA9ICcgJztcblxuICAgIGlmICh0eXBlb2YgbWFzayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIG1hc2s7XG4gICAgfVxuICAgIHJldHVybiBtYXNrW2luZGV4XSB8fCAnICc7XG59XG5mdW5jdGlvbiBkZWZhdWx0SXNDaGFyYWN0ZXJTYW1lKHJlZikge1xuICAgIHZhciBjdXJyZW50VmFsdWUgPSByZWYuY3VycmVudFZhbHVlO1xuICAgIHZhciBmb3JtYXR0ZWRWYWx1ZSA9IHJlZi5mb3JtYXR0ZWRWYWx1ZTtcbiAgICB2YXIgY3VycmVudFZhbHVlSW5kZXggPSByZWYuY3VycmVudFZhbHVlSW5kZXg7XG4gICAgdmFyIGZvcm1hdHRlZFZhbHVlSW5kZXggPSByZWYuZm9ybWF0dGVkVmFsdWVJbmRleDtcblxuICAgIHJldHVybiBjdXJyZW50VmFsdWVbY3VycmVudFZhbHVlSW5kZXhdID09PSBmb3JtYXR0ZWRWYWx1ZVtmb3JtYXR0ZWRWYWx1ZUluZGV4XTtcbn1cbmZ1bmN0aW9uIGdldENhcmV0UG9zaXRpb24obmV3Rm9ybWF0dGVkVmFsdWUsIGxhc3RGb3JtYXR0ZWRWYWx1ZSwgY3VyVmFsdWUsIGN1ckNhcmV0UG9zLCBib3VuZGFyeSwgaXNWYWxpZElucHV0Q2hhcmFjdGVyLCBcbi8qKlxuICogZm9ybWF0IGZ1bmN0aW9uIGNhbiBjaGFuZ2UgdGhlIGNoYXJhY3RlciwgdGhlIGNhcmV0IGVuZ2luZSByZWxpZXMgb24gbWFwcGluZyBvbGQgdmFsdWUgYW5kIG5ldyB2YWx1ZVxuICogSW4gc3VjaCBjYXNlIGlmIGNoYXJhY3RlciBpcyBjaGFuZ2VkLCBwYXJlbnQgY2FuIHRlbGwgd2hpY2ggY2hhcnMgYXJlIGVxdWl2YWxlbnRcbiAqIFNvbWUgZXhhbXBsZSwgYWxsIGFsbG93ZWREZWNpbWFsQ2hhcmFjdGVycyBhcmUgdXBkYXRlZCB0byBkZWNpbWFsQ2hhcmFjdGVycywgMm5kIGNhc2UgaWYgdXNlciBpcyBjb3ZlcnRpbmdcbiAqIG51bWJlciB0byBkaWZmZXJlbnQgbnVtZXJpYyBzeXN0ZW0uXG4gKi9cbmlzQ2hhcmFjdGVyU2FtZSkge1xuICAgIGlmICggaXNDaGFyYWN0ZXJTYW1lID09PSB2b2lkIDAgKSBpc0NoYXJhY3RlclNhbWUgPSBkZWZhdWx0SXNDaGFyYWN0ZXJTYW1lO1xuXG4gICAgLyoqXG4gICAgICogaWYgc29tZXRoaW5nIGdvdCBpbnNlcnRlZCBvbiBlbXB0eSB2YWx1ZSwgYWRkIHRoZSBmb3JtYXR0ZWQgY2hhcmFjdGVyIGJlZm9yZSB0aGUgY3VycmVudCB2YWx1ZSxcbiAgICAgKiBUaGlzIGlzIHRvIGF2b2lkIHRoZSBjYXNlIHdoZXJlIHR5cGVkIGNoYXJhY3RlciBpcyBwcmVzZW50IG9uIGZvcm1hdCBjaGFyYWN0ZXJzXG4gICAgICovXG4gICAgdmFyIGZpcnN0QWxsb3dlZFBvc2l0aW9uID0gYm91bmRhcnkuZmluZEluZGV4KGZ1bmN0aW9uIChiKSB7IHJldHVybiBiOyB9KTtcbiAgICB2YXIgcHJlZml4Rm9ybWF0ID0gbmV3Rm9ybWF0dGVkVmFsdWUuc2xpY2UoMCwgZmlyc3RBbGxvd2VkUG9zaXRpb24pO1xuICAgIGlmICghbGFzdEZvcm1hdHRlZFZhbHVlICYmICFjdXJWYWx1ZS5zdGFydHNXaXRoKHByZWZpeEZvcm1hdCkpIHtcbiAgICAgICAgbGFzdEZvcm1hdHRlZFZhbHVlID0gcHJlZml4Rm9ybWF0O1xuICAgICAgICBjdXJWYWx1ZSA9IHByZWZpeEZvcm1hdCArIGN1clZhbHVlO1xuICAgICAgICBjdXJDYXJldFBvcyA9IGN1ckNhcmV0UG9zICsgcHJlZml4Rm9ybWF0Lmxlbmd0aDtcbiAgICB9XG4gICAgdmFyIGN1clZhbExuID0gY3VyVmFsdWUubGVuZ3RoO1xuICAgIHZhciBmb3JtYXR0ZWRWYWx1ZUxuID0gbmV3Rm9ybWF0dGVkVmFsdWUubGVuZ3RoO1xuICAgIC8vIGNyZWF0ZSBpbmRleCBtYXBcbiAgICB2YXIgYWRkZWRJbmRleE1hcCA9IHt9O1xuICAgIHZhciBpbmRleE1hcCA9IG5ldyBBcnJheShjdXJWYWxMbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdXJWYWxMbjsgaSsrKSB7XG4gICAgICAgIGluZGV4TWFwW2ldID0gLTE7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBqTG4gPSBmb3JtYXR0ZWRWYWx1ZUxuOyBqIDwgakxuOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBpc0NoYXJTYW1lID0gaXNDaGFyYWN0ZXJTYW1lKHtcbiAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWU6IGN1clZhbHVlLFxuICAgICAgICAgICAgICAgIGxhc3RWYWx1ZTogbGFzdEZvcm1hdHRlZFZhbHVlLFxuICAgICAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlOiBuZXdGb3JtYXR0ZWRWYWx1ZSxcbiAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWVJbmRleDogaSxcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZUluZGV4OiBqLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaXNDaGFyU2FtZSAmJiBhZGRlZEluZGV4TWFwW2pdICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgaW5kZXhNYXBbaV0gPSBqO1xuICAgICAgICAgICAgICAgIGFkZGVkSW5kZXhNYXBbal0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvciBjdXJyZW50IGNhcmV0IHBvc2l0aW9uIGZpbmQgY2xvc2VzdCBjaGFyYWN0ZXJzIChsZWZ0IGFuZCByaWdodCBzaWRlKVxuICAgICAqIHdoaWNoIGFyZSBwcm9wZXJseSBtYXBwZWQgdG8gZm9ybWF0dGVkIHZhbHVlLlxuICAgICAqIFRoZSBpZGVhIGlzIHRoYXQgdGhlIG5ldyBjYXJldCBwb3NpdGlvbiB3aWxsIGV4aXN0IGFsd2F5cyBpbiB0aGUgYm91bmRhcnkgb2ZcbiAgICAgKiB0aGF0IG1hcHBlZCBpbmRleFxuICAgICAqL1xuICAgIHZhciBwb3MgPSBjdXJDYXJldFBvcztcbiAgICB3aGlsZSAocG9zIDwgY3VyVmFsTG4gJiYgKGluZGV4TWFwW3Bvc10gPT09IC0xIHx8ICFpc1ZhbGlkSW5wdXRDaGFyYWN0ZXIoY3VyVmFsdWVbcG9zXSkpKSB7XG4gICAgICAgIHBvcysrO1xuICAgIH1cbiAgICAvLyBpZiB0aGUgY2FyZXQgcG9zaXRpb24gaXMgb24gbGFzdCBrZWVwIHRoZSBlbmRJbmRleCBhcyBsYXN0IGZvciBmb3JtYXR0ZWQgdmFsdWVcbiAgICB2YXIgZW5kSW5kZXggPSBwb3MgPT09IGN1clZhbExuIHx8IGluZGV4TWFwW3Bvc10gPT09IC0xID8gZm9ybWF0dGVkVmFsdWVMbiA6IGluZGV4TWFwW3Bvc107XG4gICAgcG9zID0gY3VyQ2FyZXRQb3MgLSAxO1xuICAgIHdoaWxlIChwb3MgPiAwICYmIGluZGV4TWFwW3Bvc10gPT09IC0xKVxuICAgICAgICB7IHBvcy0tOyB9XG4gICAgdmFyIHN0YXJ0SW5kZXggPSBwb3MgPT09IC0xIHx8IGluZGV4TWFwW3Bvc10gPT09IC0xID8gMCA6IGluZGV4TWFwW3Bvc10gKyAxO1xuICAgIC8qKlxuICAgICAqIGNhc2Ugd2hlcmUgYSBjaGFyIGlzIGFkZGVkIG9uIHN1ZmZpeCBhbmQgcmVtb3ZlZCBmcm9tIG1pZGRsZSwgZXhhbXBsZSAyc3EzNDUgYmVjb21pbmcgJDIsMzQ1IHNxXG4gICAgICogdGhlcmUgaXMgc3RpbGwgYSBtYXBwaW5nIGJ1dCB0aGUgb3JkZXIgb2Ygc3RhcnQgaW5kZXggYW5kIGVuZCBpbmRleCBpcyBjaGFuZ2VkXG4gICAgICovXG4gICAgaWYgKHN0YXJ0SW5kZXggPiBlbmRJbmRleClcbiAgICAgICAgeyByZXR1cm4gZW5kSW5kZXg7IH1cbiAgICAvKipcbiAgICAgKiBnaXZlbiB0aGUgY3VycmVudCBjYXJldCBwb3NpdGlvbiBpZiBpdCBjbG9zZXIgdG8gc3RhcnRJbmRleFxuICAgICAqIGtlZXAgdGhlIG5ldyBjYXJldCBwb3NpdGlvbiBvbiBzdGFydCBpbmRleCBvciBrZWVwIGl0IGNsb3NlciB0byBlbmRJbmRleFxuICAgICAqL1xuICAgIHJldHVybiBjdXJDYXJldFBvcyAtIHN0YXJ0SW5kZXggPCBlbmRJbmRleCAtIGN1ckNhcmV0UG9zID8gc3RhcnRJbmRleCA6IGVuZEluZGV4O1xufVxuLyogVGhpcyBrZWVwcyB0aGUgY2FyZXQgd2l0aGluIHR5cGluZyBhcmVhIHNvIHBlb3BsZSBjYW4ndCB0eXBlIGluIGJldHdlZW4gcHJlZml4IG9yIHN1ZmZpeCBvciBmb3JtYXQgY2hhcmFjdGVycyAqL1xuZnVuY3Rpb24gZ2V0Q2FyZXRQb3NJbkJvdW5kYXJ5KHZhbHVlLCBjYXJldFBvcywgYm91bmRhcnksIGRpcmVjdGlvbikge1xuICAgIHZhciB2YWxMbiA9IHZhbHVlLmxlbmd0aDtcbiAgICAvLyBjbGFtcCBjYXJldCBwb3NpdGlvbiB0byBbMCwgdmFsdWUubGVuZ3RoXVxuICAgIGNhcmV0UG9zID0gY2xhbXAoY2FyZXRQb3MsIDAsIHZhbExuKTtcbiAgICBpZiAoZGlyZWN0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgd2hpbGUgKGNhcmV0UG9zID49IDAgJiYgIWJvdW5kYXJ5W2NhcmV0UG9zXSlcbiAgICAgICAgICAgIHsgY2FyZXRQb3MtLTsgfVxuICAgICAgICAvLyBpZiB3ZSBkb24ndCBmaW5kIGFueSBzdWl0YWJsZSBjYXJldCBwb3NpdGlvbiBvbiBsZWZ0LCBzZXQgaXQgb24gZmlyc3QgYWxsb3dlZCBwb3NpdGlvblxuICAgICAgICBpZiAoY2FyZXRQb3MgPT09IC0xKVxuICAgICAgICAgICAgeyBjYXJldFBvcyA9IGJvdW5kYXJ5LmluZGV4T2YodHJ1ZSk7IH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdoaWxlIChjYXJldFBvcyA8PSB2YWxMbiAmJiAhYm91bmRhcnlbY2FyZXRQb3NdKVxuICAgICAgICAgICAgeyBjYXJldFBvcysrOyB9XG4gICAgICAgIC8vIGlmIHdlIGRvbid0IGZpbmQgYW55IHN1aXRhYmxlIGNhcmV0IHBvc2l0aW9uIG9uIHJpZ2h0LCBzZXQgaXQgb24gbGFzdCBhbGxvd2VkIHBvc2l0aW9uXG4gICAgICAgIGlmIChjYXJldFBvcyA+IHZhbExuKVxuICAgICAgICAgICAgeyBjYXJldFBvcyA9IGJvdW5kYXJ5Lmxhc3RJbmRleE9mKHRydWUpOyB9XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGRvbid0IGZpbmQgY2FyZXQgcG9zaXRpb24sIHNldCBpdCBhdCB0aGUgZW5kIG9mIHZhbHVlXG4gICAgaWYgKGNhcmV0UG9zID09PSAtMSlcbiAgICAgICAgeyBjYXJldFBvcyA9IHZhbExuOyB9XG4gICAgcmV0dXJuIGNhcmV0UG9zO1xufVxuZnVuY3Rpb24gY2FyZXRVbmtub3duRm9ybWF0Qm91bmRhcnkoZm9ybWF0dGVkVmFsdWUpIHtcbiAgICB2YXIgYm91bmRhcnlBcnkgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBmb3JtYXR0ZWRWYWx1ZS5sZW5ndGggKyAxIH0pLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9KTtcbiAgICBmb3IgKHZhciBpID0gMCwgbG4gPSBib3VuZGFyeUFyeS5sZW5ndGg7IGkgPCBsbjsgaSsrKSB7XG4gICAgICAgIC8vIGNvbnNpZGVyIGNhcmV0IHRvIGJlIGluIGJvdW5kYXJ5IGlmIGl0IGlzIGJlZm9yZSBvciBhZnRlciBudW1lcmljIHZhbHVlXG4gICAgICAgIGJvdW5kYXJ5QXJ5W2ldID0gQm9vbGVhbihjaGFySXNOdW1iZXIoZm9ybWF0dGVkVmFsdWVbaV0pIHx8IGNoYXJJc051bWJlcihmb3JtYXR0ZWRWYWx1ZVtpIC0gMV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGJvdW5kYXJ5QXJ5O1xufVxuZnVuY3Rpb24gdXNlSW50ZXJuYWxWYWx1ZXModmFsdWUsIGRlZmF1bHRWYWx1ZSwgdmFsdWVJc051bWVyaWNTdHJpbmcsIGZvcm1hdCwgcmVtb3ZlRm9ybWF0dGluZywgb25WYWx1ZUNoYW5nZSkge1xuICAgIGlmICggb25WYWx1ZUNoYW5nZSA9PT0gdm9pZCAwICkgb25WYWx1ZUNoYW5nZSA9IG5vb3A7XG5cbiAgICB2YXIgZ2V0VmFsdWVzID0gdXNlUGVyc2lzdGVudENhbGxiYWNrKGZ1bmN0aW9uICh2YWx1ZSwgdmFsdWVJc051bWVyaWNTdHJpbmcpIHtcbiAgICAgICAgdmFyIGZvcm1hdHRlZFZhbHVlLCBudW1Bc1N0cmluZztcbiAgICAgICAgaWYgKGlzTm90VmFsaWRWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIG51bUFzU3RyaW5nID0gJyc7XG4gICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdmFsdWVJc051bWVyaWNTdHJpbmcpIHtcbiAgICAgICAgICAgIG51bUFzU3RyaW5nID0gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyA/IHRvTnVtZXJpY1N0cmluZyh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlID0gZm9ybWF0KG51bUFzU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG51bUFzU3RyaW5nID0gcmVtb3ZlRm9ybWF0dGluZyh2YWx1ZSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlID0gZm9ybWF0KG51bUFzU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmb3JtYXR0ZWRWYWx1ZTogZm9ybWF0dGVkVmFsdWUsIG51bUFzU3RyaW5nOiBudW1Bc1N0cmluZyB9O1xuICAgIH0pO1xuICAgIHZhciByZWYgPSB1c2VTdGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBnZXRWYWx1ZXMoaXNOaWwodmFsdWUpID8gZGVmYXVsdFZhbHVlIDogdmFsdWUsIHZhbHVlSXNOdW1lcmljU3RyaW5nKTtcbiAgICB9KTtcbiAgICB2YXIgdmFsdWVzID0gcmVmWzBdO1xuICAgIHZhciBzZXRWYWx1ZXMgPSByZWZbMV07XG4gICAgdmFyIF9vblZhbHVlQ2hhbmdlID0gZnVuY3Rpb24gKG5ld1ZhbHVlcywgc291cmNlSW5mbykge1xuICAgICAgICBpZiAobmV3VmFsdWVzLmZvcm1hdHRlZFZhbHVlICE9PSB2YWx1ZXMuZm9ybWF0dGVkVmFsdWUpIHtcbiAgICAgICAgICAgIHNldFZhbHVlcyh7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWU6IG5ld1ZhbHVlcy5mb3JtYXR0ZWRWYWx1ZSxcbiAgICAgICAgICAgICAgICBudW1Bc1N0cmluZzogbmV3VmFsdWVzLnZhbHVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2FsbCBwYXJlbnQgb24gdmFsdWUgY2hhbmdlIGlmIG9ubHkgaWYgZm9ybWF0dGVkIHZhbHVlIGlzIGNoYW5nZWRcbiAgICAgICAgb25WYWx1ZUNoYW5nZShuZXdWYWx1ZXMsIHNvdXJjZUluZm8pO1xuICAgIH07XG4gICAgLy8gaWYgdmFsdWUgaXMgc3dpdGNoIGZyb20gY29udHJvbGxlZCB0byB1bmNvbnRyb2xsZWQsIHVzZSB0aGUgaW50ZXJuYWwgc3RhdGUncyB2YWx1ZSB0byBmb3JtYXQgd2l0aCBuZXcgcHJvcHNcbiAgICB2YXIgX3ZhbHVlID0gdmFsdWU7XG4gICAgdmFyIF92YWx1ZUlzTnVtZXJpY1N0cmluZyA9IHZhbHVlSXNOdW1lcmljU3RyaW5nO1xuICAgIGlmIChpc05pbCh2YWx1ZSkpIHtcbiAgICAgICAgX3ZhbHVlID0gdmFsdWVzLm51bUFzU3RyaW5nO1xuICAgICAgICBfdmFsdWVJc051bWVyaWNTdHJpbmcgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgbmV3VmFsdWVzID0gZ2V0VmFsdWVzKF92YWx1ZSwgX3ZhbHVlSXNOdW1lcmljU3RyaW5nKTtcbiAgICB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0VmFsdWVzKG5ld1ZhbHVlcyk7XG4gICAgfSwgW25ld1ZhbHVlcy5mb3JtYXR0ZWRWYWx1ZV0pO1xuICAgIHJldHVybiBbdmFsdWVzLCBfb25WYWx1ZUNoYW5nZV07XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRSZW1vdmVGb3JtYXR0aW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1teMC05XS9nLCAnJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Rm9ybWF0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gTnVtYmVyRm9ybWF0QmFzZShwcm9wcykge1xuICAgIHZhciB0eXBlID0gcHJvcHMudHlwZTsgaWYgKCB0eXBlID09PSB2b2lkIDAgKSB0eXBlID0gJ3RleHQnO1xuICAgIHZhciBkaXNwbGF5VHlwZSA9IHByb3BzLmRpc3BsYXlUeXBlOyBpZiAoIGRpc3BsYXlUeXBlID09PSB2b2lkIDAgKSBkaXNwbGF5VHlwZSA9ICdpbnB1dCc7XG4gICAgdmFyIGN1c3RvbUlucHV0ID0gcHJvcHMuY3VzdG9tSW5wdXQ7XG4gICAgdmFyIHJlbmRlclRleHQgPSBwcm9wcy5yZW5kZXJUZXh0O1xuICAgIHZhciBnZXRJbnB1dFJlZiA9IHByb3BzLmdldElucHV0UmVmO1xuICAgIHZhciBmb3JtYXQgPSBwcm9wcy5mb3JtYXQ7IGlmICggZm9ybWF0ID09PSB2b2lkIDAgKSBmb3JtYXQgPSBkZWZhdWx0Rm9ybWF0O1xuICAgIHZhciByZW1vdmVGb3JtYXR0aW5nID0gcHJvcHMucmVtb3ZlRm9ybWF0dGluZzsgaWYgKCByZW1vdmVGb3JtYXR0aW5nID09PSB2b2lkIDAgKSByZW1vdmVGb3JtYXR0aW5nID0gZGVmYXVsdFJlbW92ZUZvcm1hdHRpbmc7XG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICB2YXIgdmFsdWVJc051bWVyaWNTdHJpbmcgPSBwcm9wcy52YWx1ZUlzTnVtZXJpY1N0cmluZztcbiAgICB2YXIgb25WYWx1ZUNoYW5nZSA9IHByb3BzLm9uVmFsdWVDaGFuZ2U7XG4gICAgdmFyIGlzQWxsb3dlZCA9IHByb3BzLmlzQWxsb3dlZDtcbiAgICB2YXIgb25DaGFuZ2UgPSBwcm9wcy5vbkNoYW5nZTsgaWYgKCBvbkNoYW5nZSA9PT0gdm9pZCAwICkgb25DaGFuZ2UgPSBub29wO1xuICAgIHZhciBvbktleURvd24gPSBwcm9wcy5vbktleURvd247IGlmICggb25LZXlEb3duID09PSB2b2lkIDAgKSBvbktleURvd24gPSBub29wO1xuICAgIHZhciBvbk1vdXNlVXAgPSBwcm9wcy5vbk1vdXNlVXA7IGlmICggb25Nb3VzZVVwID09PSB2b2lkIDAgKSBvbk1vdXNlVXAgPSBub29wO1xuICAgIHZhciBvbkZvY3VzID0gcHJvcHMub25Gb2N1czsgaWYgKCBvbkZvY3VzID09PSB2b2lkIDAgKSBvbkZvY3VzID0gbm9vcDtcbiAgICB2YXIgb25CbHVyID0gcHJvcHMub25CbHVyOyBpZiAoIG9uQmx1ciA9PT0gdm9pZCAwICkgb25CbHVyID0gbm9vcDtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHMudmFsdWU7XG4gICAgdmFyIGdldENhcmV0Qm91bmRhcnkgPSBwcm9wcy5nZXRDYXJldEJvdW5kYXJ5OyBpZiAoIGdldENhcmV0Qm91bmRhcnkgPT09IHZvaWQgMCApIGdldENhcmV0Qm91bmRhcnkgPSBjYXJldFVua25vd25Gb3JtYXRCb3VuZGFyeTtcbiAgICB2YXIgaXNWYWxpZElucHV0Q2hhcmFjdGVyID0gcHJvcHMuaXNWYWxpZElucHV0Q2hhcmFjdGVyOyBpZiAoIGlzVmFsaWRJbnB1dENoYXJhY3RlciA9PT0gdm9pZCAwICkgaXNWYWxpZElucHV0Q2hhcmFjdGVyID0gY2hhcklzTnVtYmVyO1xuICAgIHZhciBpc0NoYXJhY3RlclNhbWUgPSBwcm9wcy5pc0NoYXJhY3RlclNhbWU7XG4gICAgdmFyIG90aGVyUHJvcHMgPSBfX3Jlc3QocHJvcHMsIFtcInR5cGVcIiwgXCJkaXNwbGF5VHlwZVwiLCBcImN1c3RvbUlucHV0XCIsIFwicmVuZGVyVGV4dFwiLCBcImdldElucHV0UmVmXCIsIFwiZm9ybWF0XCIsIFwicmVtb3ZlRm9ybWF0dGluZ1wiLCBcImRlZmF1bHRWYWx1ZVwiLCBcInZhbHVlSXNOdW1lcmljU3RyaW5nXCIsIFwib25WYWx1ZUNoYW5nZVwiLCBcImlzQWxsb3dlZFwiLCBcIm9uQ2hhbmdlXCIsIFwib25LZXlEb3duXCIsIFwib25Nb3VzZVVwXCIsIFwib25Gb2N1c1wiLCBcIm9uQmx1clwiLCBcInZhbHVlXCIsIFwiZ2V0Q2FyZXRCb3VuZGFyeVwiLCBcImlzVmFsaWRJbnB1dENoYXJhY3RlclwiLCBcImlzQ2hhcmFjdGVyU2FtZVwiXSk7XG4gICAgdmFyIHJlZiA9IHVzZUludGVybmFsVmFsdWVzKHByb3BWYWx1ZSwgZGVmYXVsdFZhbHVlLCBCb29sZWFuKHZhbHVlSXNOdW1lcmljU3RyaW5nKSwgZm9ybWF0LCByZW1vdmVGb3JtYXR0aW5nLCBvblZhbHVlQ2hhbmdlKTtcbiAgICB2YXIgcmVmXzAgPSByZWZbMF07XG4gICAgdmFyIGZvcm1hdHRlZFZhbHVlID0gcmVmXzAuZm9ybWF0dGVkVmFsdWU7XG4gICAgdmFyIG51bUFzU3RyaW5nID0gcmVmXzAubnVtQXNTdHJpbmc7XG4gICAgdmFyIG9uRm9ybWF0dGVkVmFsdWVDaGFuZ2UgPSByZWZbMV07XG4gICAgdmFyIGNhcmV0UG9zaXRpb25CZWZvcmVDaGFuZ2UgPSB1c2VSZWYoKTtcbiAgICB2YXIgbGFzdFVwZGF0ZWRWYWx1ZSA9IHVzZVJlZih7IGZvcm1hdHRlZFZhbHVlOiBmb3JtYXR0ZWRWYWx1ZSwgbnVtQXNTdHJpbmc6IG51bUFzU3RyaW5nIH0pO1xuICAgIHZhciBfb25WYWx1ZUNoYW5nZSA9IGZ1bmN0aW9uICh2YWx1ZXMsIHNvdXJjZSkge1xuICAgICAgICBsYXN0VXBkYXRlZFZhbHVlLmN1cnJlbnQgPSB7IGZvcm1hdHRlZFZhbHVlOiB2YWx1ZXMuZm9ybWF0dGVkVmFsdWUsIG51bUFzU3RyaW5nOiB2YWx1ZXMudmFsdWUgfTtcbiAgICAgICAgb25Gb3JtYXR0ZWRWYWx1ZUNoYW5nZSh2YWx1ZXMsIHNvdXJjZSk7XG4gICAgfTtcbiAgICB2YXIgcmVmJDEgPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgdmFyIG1vdW50ZWQgPSByZWYkMVswXTtcbiAgICB2YXIgc2V0TW91bnRlZCA9IHJlZiQxWzFdO1xuICAgIHZhciBmb2N1c2VkRWxtID0gdXNlUmVmKG51bGwpO1xuICAgIHZhciB0aW1lb3V0ID0gdXNlUmVmKHtcbiAgICAgICAgc2V0Q2FyZXRUaW1lb3V0OiBudWxsLFxuICAgICAgICBmb2N1c1RpbWVvdXQ6IG51bGwsXG4gICAgfSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0TW91bnRlZCh0cnVlKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0LmN1cnJlbnQuc2V0Q2FyZXRUaW1lb3V0KTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0LmN1cnJlbnQuZm9jdXNUaW1lb3V0KTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgdmFyIF9mb3JtYXQgPSBmb3JtYXQ7XG4gICAgdmFyIGdldFZhbHVlT2JqZWN0ID0gZnVuY3Rpb24gKGZvcm1hdHRlZFZhbHVlLCBudW1Bc1N0cmluZykge1xuICAgICAgICB2YXIgZmxvYXRWYWx1ZSA9IHBhcnNlRmxvYXQobnVtQXNTdHJpbmcpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWU6IGZvcm1hdHRlZFZhbHVlLFxuICAgICAgICAgICAgdmFsdWU6IG51bUFzU3RyaW5nLFxuICAgICAgICAgICAgZmxvYXRWYWx1ZTogaXNOYU4oZmxvYXRWYWx1ZSkgPyB1bmRlZmluZWQgOiBmbG9hdFZhbHVlLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgdmFyIHNldFBhdGNoZWRDYXJldFBvc2l0aW9uID0gZnVuY3Rpb24gKGVsLCBjYXJldFBvcywgY3VycmVudFZhbHVlKSB7XG4gICAgICAgIC8vIGRvbid0IHJlc2V0IHRoZSBjYXJldCBwb3NpdGlvbiB3aGVuIHRoZSB3aG9sZSBpbnB1dCBjb250ZW50IGlzIHNlbGVjdGVkXG4gICAgICAgIGlmIChlbC5zZWxlY3Rpb25TdGFydCA9PT0gMCAmJiBlbC5zZWxlY3Rpb25FbmQgPT09IGVsLnZhbHVlLmxlbmd0aClcbiAgICAgICAgICAgIHsgcmV0dXJuOyB9XG4gICAgICAgIC8qIHNldHRpbmcgY2FyZXQgcG9zaXRpb24gd2l0aGluIHRpbWVvdXQgb2YgMG1zIGlzIHJlcXVpcmVkIGZvciBtb2JpbGUgY2hyb21lLFxuICAgICAgICBvdGhlcndpc2UgYnJvd3NlciByZXNldHMgdGhlIGNhcmV0IHBvc2l0aW9uIGFmdGVyIHdlIHNldCBpdFxuICAgICAgICBXZSBhcmUgYWxzbyBzZXR0aW5nIGl0IHdpdGhvdXQgdGltZW91dCBzbyB0aGF0IGluIG5vcm1hbCBicm93c2VyIHdlIGRvbid0IHNlZSB0aGUgZmxpY2tlcmluZyAqL1xuICAgICAgICBzZXRDYXJldFBvc2l0aW9uKGVsLCBjYXJldFBvcyk7XG4gICAgICAgIHRpbWVvdXQuY3VycmVudC5zZXRDYXJldFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChlbC52YWx1ZSA9PT0gY3VycmVudFZhbHVlICYmIGVsLnNlbGVjdGlvblN0YXJ0ICE9PSBjYXJldFBvcykge1xuICAgICAgICAgICAgICAgIHNldENhcmV0UG9zaXRpb24oZWwsIGNhcmV0UG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgfTtcbiAgICAvKiBUaGlzIGtlZXBzIHRoZSBjYXJldCB3aXRoaW4gdHlwaW5nIGFyZWEgc28gcGVvcGxlIGNhbid0IHR5cGUgaW4gYmV0d2VlbiBwcmVmaXggb3Igc3VmZml4ICovXG4gICAgdmFyIGNvcnJlY3RDYXJldFBvc2l0aW9uID0gZnVuY3Rpb24gKHZhbHVlLCBjYXJldFBvcywgZGlyZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBnZXRDYXJldFBvc0luQm91bmRhcnkodmFsdWUsIGNhcmV0UG9zLCBnZXRDYXJldEJvdW5kYXJ5KHZhbHVlKSwgZGlyZWN0aW9uKTtcbiAgICB9O1xuICAgIHZhciBnZXROZXdDYXJldFBvc2l0aW9uID0gZnVuY3Rpb24gKGlucHV0VmFsdWUsIG5ld0Zvcm1hdHRlZFZhbHVlLCBjYXJldFBvcykge1xuICAgICAgICB2YXIgY2FyZXRCb3VuZGFyeSA9IGdldENhcmV0Qm91bmRhcnkobmV3Rm9ybWF0dGVkVmFsdWUpO1xuICAgICAgICB2YXIgdXBkYXRlZENhcmV0UG9zID0gZ2V0Q2FyZXRQb3NpdGlvbihuZXdGb3JtYXR0ZWRWYWx1ZSwgZm9ybWF0dGVkVmFsdWUsIGlucHV0VmFsdWUsIGNhcmV0UG9zLCBjYXJldEJvdW5kYXJ5LCBpc1ZhbGlkSW5wdXRDaGFyYWN0ZXIsIGlzQ2hhcmFjdGVyU2FtZSk7XG4gICAgICAgIC8vY29ycmVjdCBjYXJldCBwb3NpdGlvbiBpZiBpdHMgb3V0c2lkZSBvZiBlZGl0YWJsZSBhcmVhXG4gICAgICAgIHVwZGF0ZWRDYXJldFBvcyA9IGdldENhcmV0UG9zSW5Cb3VuZGFyeShuZXdGb3JtYXR0ZWRWYWx1ZSwgdXBkYXRlZENhcmV0UG9zLCBjYXJldEJvdW5kYXJ5KTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZWRDYXJldFBvcztcbiAgICB9O1xuICAgIHZhciB1cGRhdGVWYWx1ZUFuZENhcmV0UG9zaXRpb24gPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciBuZXdGb3JtYXR0ZWRWYWx1ZSA9IHBhcmFtcy5mb3JtYXR0ZWRWYWx1ZTsgaWYgKCBuZXdGb3JtYXR0ZWRWYWx1ZSA9PT0gdm9pZCAwICkgbmV3Rm9ybWF0dGVkVmFsdWUgPSAnJztcbiAgICAgICAgdmFyIGlucHV0ID0gcGFyYW1zLmlucHV0O1xuICAgICAgICB2YXIgc291cmNlID0gcGFyYW1zLnNvdXJjZTtcbiAgICAgICAgdmFyIGV2ZW50ID0gcGFyYW1zLmV2ZW50O1xuICAgICAgICB2YXIgbnVtQXNTdHJpbmcgPSBwYXJhbXMubnVtQXNTdHJpbmc7XG4gICAgICAgIHZhciBjYXJldFBvcztcbiAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRWYWx1ZSA9IHBhcmFtcy5pbnB1dFZhbHVlIHx8IGlucHV0LnZhbHVlO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRDYXJldFBvc2l0aW9uID0gZ2VJbnB1dENhcmV0UG9zaXRpb24oaW5wdXQpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBzZXQgdGhlIHZhbHVlIGltcGVyYXRpdmVseSwgdGhpcyBpcyByZXF1aXJlZCBmb3IgSUUgZml4XG4gICAgICAgICAgICAgKiBUaGlzIGlzIGFsc28gcmVxdWlyZWQgYXMgaWYgbmV3IGNhcmV0IHBvc2l0aW9uIGlzIGJleW9uZCB0aGUgcHJldmlvdXMgdmFsdWUuXG4gICAgICAgICAgICAgKiBDYXJldCBwb3NpdGlvbiB3aWxsIG5vdCBiZSBzZXQgY29ycmVjdGx5XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlucHV0LnZhbHVlID0gbmV3Rm9ybWF0dGVkVmFsdWU7XG4gICAgICAgICAgICAvL2dldCB0aGUgY2FyZXQgcG9zaXRpb25cbiAgICAgICAgICAgIGNhcmV0UG9zID0gZ2V0TmV3Q2FyZXRQb3NpdGlvbihpbnB1dFZhbHVlLCBuZXdGb3JtYXR0ZWRWYWx1ZSwgY3VycmVudENhcmV0UG9zaXRpb24pO1xuICAgICAgICAgICAgLy9zZXQgY2FyZXQgcG9zaXRpb24gaW1wZXJhdGl2ZWx5XG4gICAgICAgICAgICBpZiAoY2FyZXRQb3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNldFBhdGNoZWRDYXJldFBvc2l0aW9uKGlucHV0LCBjYXJldFBvcywgbmV3Rm9ybWF0dGVkVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdGb3JtYXR0ZWRWYWx1ZSAhPT0gZm9ybWF0dGVkVmFsdWUpIHtcbiAgICAgICAgICAgIC8vIHRyaWdnZXIgb25WYWx1ZUNoYW5nZSBzeW5jaHJvbm91c2x5LCBzbyBwYXJlbnQgaXMgdXBkYXRlZCBhbG9uZyB3aXRoIHRoZSBudW1iZXIgZm9ybWF0LiBGaXggZm9yICMyNzcsICMyODdcbiAgICAgICAgICAgIF9vblZhbHVlQ2hhbmdlKGdldFZhbHVlT2JqZWN0KG5ld0Zvcm1hdHRlZFZhbHVlLCBudW1Bc1N0cmluZyksIHsgZXZlbnQ6IGV2ZW50LCBzb3VyY2U6IHNvdXJjZSB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogaWYgdGhlIGZvcm1hdHRlZCB2YWx1ZSBpcyBub3Qgc3luY2VkIHRvIHBhcmVudCwgb3IgaWYgdGhlIGZvcm1hdHRlZCB2YWx1ZSBpcyBkaWZmZXJlbnQgZnJvbSBsYXN0IHN5bmNlZCB2YWx1ZSBzeW5jIGl0XG4gICAgICogaWYgdGhlIGZvcm1hdHRpbmcgcHJvcHMgaXMgcmVtb3ZlZCwgaW4gd2hpY2ggY2FzZSBsYXN0IGZvcm1hdHRlZCB2YWx1ZSB3aWxsIGJlIGRpZmZlcmVudCBmcm9tIHRoZSBudW1lcmljIHN0cmluZyB2YWx1ZVxuICAgICAqIGluIHN1Y2ggY2FzZSB3ZSBuZWVkIHRvIGluZm9ybSB0aGUgcGFyZW50LlxuICAgICAqL1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZWYgPSBsYXN0VXBkYXRlZFZhbHVlLmN1cnJlbnQ7XG4gICAgICAgIHZhciBsYXN0Rm9ybWF0dGVkVmFsdWUgPSByZWYuZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgIHZhciBsYXN0TnVtQXNTdHJpbmcgPSByZWYubnVtQXNTdHJpbmc7XG4gICAgICAgIGlmIChmb3JtYXR0ZWRWYWx1ZSAhPT0gbGFzdEZvcm1hdHRlZFZhbHVlIHx8IG51bUFzU3RyaW5nICE9PSBsYXN0TnVtQXNTdHJpbmcpIHtcbiAgICAgICAgICAgIF9vblZhbHVlQ2hhbmdlKGdldFZhbHVlT2JqZWN0KGZvcm1hdHRlZFZhbHVlLCBudW1Bc1N0cmluZyksIHtcbiAgICAgICAgICAgICAgICBldmVudDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHNvdXJjZTogU291cmNlVHlwZS5wcm9wcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW2Zvcm1hdHRlZFZhbHVlLCBudW1Bc1N0cmluZ10pO1xuICAgIC8vIGFsc28gaWYgZm9ybWF0dGVkIHZhbHVlIGlzIGNoYW5nZWQgZnJvbSB0aGUgcHJvcHMsIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBjYXJldCBwb3NpdGlvblxuICAgIC8vIGtlZXAgdGhlIGxhc3QgY2FyZXQgcG9zaXRpb24gaWYgZWxlbWVudCBpcyBmb2N1c2VkXG4gICAgdmFyIGN1cnJlbnRDYXJldFBvc2l0aW9uID0gZm9jdXNlZEVsbS5jdXJyZW50XG4gICAgICAgID8gZ2VJbnB1dENhcmV0UG9zaXRpb24oZm9jdXNlZEVsbS5jdXJyZW50KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAvLyBuZWVkZWQgdG8gcHJldmVudCB3YXJuaW5nIHdpdGggdXNlTGF5b3V0RWZmZWN0IG9uIHNlcnZlclxuICAgIHZhciB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGZvY3VzZWRFbG0uY3VycmVudDtcbiAgICAgICAgaWYgKGZvcm1hdHRlZFZhbHVlICE9PSBsYXN0VXBkYXRlZFZhbHVlLmN1cnJlbnQuZm9ybWF0dGVkVmFsdWUgJiYgaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciBjYXJldFBvcyA9IGdldE5ld0NhcmV0UG9zaXRpb24obGFzdFVwZGF0ZWRWYWx1ZS5jdXJyZW50LmZvcm1hdHRlZFZhbHVlLCBmb3JtYXR0ZWRWYWx1ZSwgY3VycmVudENhcmV0UG9zaXRpb24pO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBzZXQgdGhlIHZhbHVlIGltcGVyYXRpdmVseSwgYXMgd2Ugc2V0IHRoZSBjYXJldCBwb3NpdGlvbiBhcyB3ZWxsIGltcGVyYXRpdmVseS5cbiAgICAgICAgICAgICAqIFRoaXMgaXMgdG8ga2VlcCB2YWx1ZSBhbmQgY2FyZXQgcG9zaXRpb24gaW4gc3luY1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpbnB1dC52YWx1ZSA9IGZvcm1hdHRlZFZhbHVlO1xuICAgICAgICAgICAgc2V0UGF0Y2hlZENhcmV0UG9zaXRpb24oaW5wdXQsIGNhcmV0UG9zLCBmb3JtYXR0ZWRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9LCBbZm9ybWF0dGVkVmFsdWVdKTtcbiAgICB2YXIgZm9ybWF0SW5wdXRWYWx1ZSA9IGZ1bmN0aW9uIChpbnB1dFZhbHVlLCBldmVudCwgc291cmNlKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgdmFyIGNoYW5nZVJhbmdlID0gY2FyZXRQb3NpdGlvbkJlZm9yZUNoYW5nZS5jdXJyZW50XG4gICAgICAgICAgICA/IGZpbmRDaGFuZ2VkUmFuZ2VGcm9tQ2FyZXRQb3NpdGlvbnMoY2FyZXRQb3NpdGlvbkJlZm9yZUNoYW5nZS5jdXJyZW50LCBpbnB1dC5zZWxlY3Rpb25FbmQpXG4gICAgICAgICAgICA6IGZpbmRDaGFuZ2VSYW5nZShmb3JtYXR0ZWRWYWx1ZSwgaW5wdXRWYWx1ZSk7XG4gICAgICAgIHZhciBjaGFuZ2VNZXRhID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjaGFuZ2VSYW5nZSksIHsgbGFzdFZhbHVlOiBmb3JtYXR0ZWRWYWx1ZSB9KTtcbiAgICAgICAgdmFyIF9udW1Bc1N0cmluZyA9IHJlbW92ZUZvcm1hdHRpbmcoaW5wdXRWYWx1ZSwgY2hhbmdlTWV0YSk7XG4gICAgICAgIHZhciBfZm9ybWF0dGVkVmFsdWUgPSBfZm9ybWF0KF9udW1Bc1N0cmluZyk7XG4gICAgICAgIC8vIGZvcm1hdHRpbmcgY2FuIHJlbW92ZSBzb21lIG9mIHRoZSBudW1iZXIgY2hhcnMsIHNvIHdlIG5lZWQgdG8gZmluZSBudW1iZXIgc3RyaW5nIGFnYWluXG4gICAgICAgIF9udW1Bc1N0cmluZyA9IHJlbW92ZUZvcm1hdHRpbmcoX2Zvcm1hdHRlZFZhbHVlLCB1bmRlZmluZWQpO1xuICAgICAgICBpZiAoaXNBbGxvd2VkICYmICFpc0FsbG93ZWQoZ2V0VmFsdWVPYmplY3QoX2Zvcm1hdHRlZFZhbHVlLCBfbnVtQXNTdHJpbmcpKSkge1xuICAgICAgICAgICAgLy9yZXNldCB0aGUgY2FyZXQgcG9zaXRpb25cbiAgICAgICAgICAgIHZhciBpbnB1dCQxID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRDYXJldFBvc2l0aW9uID0gZ2VJbnB1dENhcmV0UG9zaXRpb24oaW5wdXQkMSk7XG4gICAgICAgICAgICB2YXIgY2FyZXRQb3MgPSBnZXROZXdDYXJldFBvc2l0aW9uKGlucHV0VmFsdWUsIGZvcm1hdHRlZFZhbHVlLCBjdXJyZW50Q2FyZXRQb3NpdGlvbik7XG4gICAgICAgICAgICBpbnB1dCQxLnZhbHVlID0gZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgICAgICBzZXRQYXRjaGVkQ2FyZXRQb3NpdGlvbihpbnB1dCQxLCBjYXJldFBvcywgZm9ybWF0dGVkVmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZVZhbHVlQW5kQ2FyZXRQb3NpdGlvbih7XG4gICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZTogX2Zvcm1hdHRlZFZhbHVlLFxuICAgICAgICAgICAgbnVtQXNTdHJpbmc6IF9udW1Bc1N0cmluZyxcbiAgICAgICAgICAgIGlucHV0VmFsdWU6IGlucHV0VmFsdWUsXG4gICAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgIGlucHV0OiBldmVudC50YXJnZXQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIHZhciBzZXRDYXJldFBvc2l0aW9uSW5mb0JlZm9yZUNoYW5nZSA9IGZ1bmN0aW9uIChlbCwgZW5kT2Zmc2V0KSB7XG4gICAgICAgIGlmICggZW5kT2Zmc2V0ID09PSB2b2lkIDAgKSBlbmRPZmZzZXQgPSAwO1xuXG4gICAgICAgIHZhciBzZWxlY3Rpb25TdGFydCA9IGVsLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICB2YXIgc2VsZWN0aW9uRW5kID0gZWwuc2VsZWN0aW9uRW5kO1xuICAgICAgICBjYXJldFBvc2l0aW9uQmVmb3JlQ2hhbmdlLmN1cnJlbnQgPSB7IHNlbGVjdGlvblN0YXJ0OiBzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kOiBzZWxlY3Rpb25FbmQgKyBlbmRPZmZzZXQgfTtcbiAgICB9O1xuICAgIHZhciBfb25DaGFuZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgZWwgPSBlLnRhcmdldDtcbiAgICAgICAgdmFyIGlucHV0VmFsdWUgPSBlbC52YWx1ZTtcbiAgICAgICAgdmFyIGNoYW5nZWQgPSBmb3JtYXRJbnB1dFZhbHVlKGlucHV0VmFsdWUsIGUsIFNvdXJjZVR5cGUuZXZlbnQpO1xuICAgICAgICBpZiAoY2hhbmdlZClcbiAgICAgICAgICAgIHsgb25DaGFuZ2UoZSk7IH1cbiAgICAgICAgLy8gcmVzZXQgdGhlIHBvc2l0aW9uLCBhcyB3ZSBoYXZlIGFscmVhZHkgaGFuZGxlZCB0aGUgY2FyZXQgcG9zaXRpb25cbiAgICAgICAgY2FyZXRQb3NpdGlvbkJlZm9yZUNoYW5nZS5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgdmFyIF9vbktleURvd24gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgZWwgPSBlLnRhcmdldDtcbiAgICAgICAgdmFyIGtleSA9IGUua2V5O1xuICAgICAgICB2YXIgc2VsZWN0aW9uU3RhcnQgPSBlbC5zZWxlY3Rpb25TdGFydDtcbiAgICAgICAgdmFyIHNlbGVjdGlvbkVuZCA9IGVsLnNlbGVjdGlvbkVuZDtcbiAgICAgICAgdmFyIHZhbHVlID0gZWwudmFsdWU7IGlmICggdmFsdWUgPT09IHZvaWQgMCApIHZhbHVlID0gJyc7XG4gICAgICAgIHZhciBleHBlY3RlZENhcmV0UG9zaXRpb247XG4gICAgICAgIC8vSGFuZGxlIGJhY2tzcGFjZSBhbmQgZGVsZXRlIGFnYWluc3Qgbm9uIG51bWVyaWNhbC9kZWNpbWFsIGNoYXJhY3RlcnMgb3IgYXJyb3cga2V5c1xuICAgICAgICBpZiAoa2V5ID09PSAnQXJyb3dMZWZ0JyB8fCBrZXkgPT09ICdCYWNrc3BhY2UnKSB7XG4gICAgICAgICAgICBleHBlY3RlZENhcmV0UG9zaXRpb24gPSBNYXRoLm1heChzZWxlY3Rpb25TdGFydCAtIDEsIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ0Fycm93UmlnaHQnKSB7XG4gICAgICAgICAgICBleHBlY3RlZENhcmV0UG9zaXRpb24gPSBNYXRoLm1pbihzZWxlY3Rpb25TdGFydCArIDEsIHZhbHVlLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnRGVsZXRlJykge1xuICAgICAgICAgICAgZXhwZWN0ZWRDYXJldFBvc2l0aW9uID0gc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYga2V5IGlzIGRlbGV0ZSBhbmQgdGV4dCBpcyBub3Qgc2VsZWN0ZWQga2VlcCB0aGUgZW5kIG9mZnNldCB0byAxLCBhcyBpdCBkZWxldGVzIG9uZSBjaGFyYWN0ZXJcbiAgICAgICAgLy8gdGhpcyBpcyByZXF1aXJlZCBhcyBzZWxlY3Rpb24gaXMgbm90IGNoYW5nZWQgb24gZGVsZXRlIGNhc2UsIHdoaWNoIGNoYW5nZXMgdGhlIGNoYW5nZSByYW5nZSBjYWxjdWxhdGlvblxuICAgICAgICB2YXIgZW5kT2Zmc2V0ID0gMDtcbiAgICAgICAgaWYgKGtleSA9PT0gJ0RlbGV0ZScgJiYgc2VsZWN0aW9uU3RhcnQgPT09IHNlbGVjdGlvbkVuZCkge1xuICAgICAgICAgICAgZW5kT2Zmc2V0ID0gMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNBcnJvd0tleSA9IGtleSA9PT0gJ0Fycm93TGVmdCcgfHwga2V5ID09PSAnQXJyb3dSaWdodCc7XG4gICAgICAgIC8vaWYgZXhwZWN0ZWRDYXJldFBvc2l0aW9uIGlzIG5vdCBzZXQgaXQgbWVhbnMgd2UgZG9uJ3Qgd2FudCB0byBIYW5kbGUga2V5RG93blxuICAgICAgICAvLyBhbHNvIGlmIG11bHRpcGxlIGNoYXJhY3RlcnMgYXJlIHNlbGVjdGVkIGRvbid0IGhhbmRsZVxuICAgICAgICBpZiAoZXhwZWN0ZWRDYXJldFBvc2l0aW9uID09PSB1bmRlZmluZWQgfHwgKHNlbGVjdGlvblN0YXJ0ICE9PSBzZWxlY3Rpb25FbmQgJiYgIWlzQXJyb3dLZXkpKSB7XG4gICAgICAgICAgICBvbktleURvd24oZSk7XG4gICAgICAgICAgICAvLyBrZWVwIGluZm9ybWF0aW9uIG9mIHdoYXQgd2FzIHRoZSBjYXJldCBwb3NpdGlvbiBiZWZvcmUga2V5RG93blxuICAgICAgICAgICAgLy8gc2V0IGl0IGFmdGVyIG9uS2V5RG93biwgaW4gY2FzZSBwYXJlbnQgdXBkYXRlcyB0aGUgcG9zaXRpb24gbWFudWFsbHlcbiAgICAgICAgICAgIHNldENhcmV0UG9zaXRpb25JbmZvQmVmb3JlQ2hhbmdlKGVsLCBlbmRPZmZzZXQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdDYXJldFBvc2l0aW9uID0gZXhwZWN0ZWRDYXJldFBvc2l0aW9uO1xuICAgICAgICBpZiAoaXNBcnJvd0tleSkge1xuICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGtleSA9PT0gJ0Fycm93TGVmdCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgICAgICAgbmV3Q2FyZXRQb3NpdGlvbiA9IGNvcnJlY3RDYXJldFBvc2l0aW9uKHZhbHVlLCBleHBlY3RlZENhcmV0UG9zaXRpb24sIGRpcmVjdGlvbik7XG4gICAgICAgICAgICAvLyBhcnJvdyBsZWZ0IG9yIHJpZ2h0IG9ubHkgbW92ZXMgdGhlIGNhcmV0LCBzbyBubyBuZWVkIHRvIGhhbmRsZSB0aGUgZXZlbnQsIGlmIHdlIGFyZSBoYW5kbGluZyBpdCBtYW51YWxseVxuICAgICAgICAgICAgaWYgKG5ld0NhcmV0UG9zaXRpb24gIT09IGV4cGVjdGVkQ2FyZXRQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdEZWxldGUnICYmICFpc1ZhbGlkSW5wdXRDaGFyYWN0ZXIodmFsdWVbZXhwZWN0ZWRDYXJldFBvc2l0aW9uXSkpIHtcbiAgICAgICAgICAgIC8vIGluIGNhc2Ugb2YgZGVsZXRlIGdvIHRvIGNsb3Nlc3QgY2FyZXQgYm91bmRhcnkgb24gdGhlIHJpZ2h0IHNpZGVcbiAgICAgICAgICAgIG5ld0NhcmV0UG9zaXRpb24gPSBjb3JyZWN0Q2FyZXRQb3NpdGlvbih2YWx1ZSwgZXhwZWN0ZWRDYXJldFBvc2l0aW9uLCAncmlnaHQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdCYWNrc3BhY2UnICYmICFpc1ZhbGlkSW5wdXRDaGFyYWN0ZXIodmFsdWVbZXhwZWN0ZWRDYXJldFBvc2l0aW9uXSkpIHtcbiAgICAgICAgICAgIC8vIGluIGNhc2Ugb2YgYmFja3NwYWNlIGdvIHRvIGNsb3Nlc3QgY2FyZXQgYm91bmRhcnkgb24gdGhlIGxlZnQgc2lkZVxuICAgICAgICAgICAgbmV3Q2FyZXRQb3NpdGlvbiA9IGNvcnJlY3RDYXJldFBvc2l0aW9uKHZhbHVlLCBleHBlY3RlZENhcmV0UG9zaXRpb24sICdsZWZ0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0NhcmV0UG9zaXRpb24gIT09IGV4cGVjdGVkQ2FyZXRQb3NpdGlvbikge1xuICAgICAgICAgICAgc2V0UGF0Y2hlZENhcmV0UG9zaXRpb24oZWwsIG5ld0NhcmV0UG9zaXRpb24sIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBvbktleURvd24oZSk7XG4gICAgICAgIHNldENhcmV0UG9zaXRpb25JbmZvQmVmb3JlQ2hhbmdlKGVsLCBlbmRPZmZzZXQpO1xuICAgIH07XG4gICAgLyoqIHJlcXVpcmVkIHRvIGhhbmRsZSB0aGUgY2FyZXQgcG9zaXRpb24gd2hlbiBjbGljayBhbnl3aGVyZSB3aXRoaW4gdGhlIGlucHV0ICoqL1xuICAgIHZhciBfb25Nb3VzZVVwID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGVsID0gZS50YXJnZXQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOT1RFOiB3ZSBoYXZlIHRvIGdpdmUgZGVmYXVsdCB2YWx1ZSBmb3IgdmFsdWUgYXMgaW4gY2FzZSB3aGVuIGN1c3RvbSBpbnB1dCBpcyBwcm92aWRlZFxuICAgICAgICAgKiB2YWx1ZSBjYW4gY29tZSBhcyB1bmRlZmluZWQgd2hlbiBub3RoaW5nIGlzIHByb3ZpZGVkIG9uIHZhbHVlIHByb3AuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgY29ycmVjdENhcmV0UG9zaXRpb25JZlJlcXVpcmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvblN0YXJ0ID0gZWwuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uRW5kID0gZWwuc2VsZWN0aW9uRW5kO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZWwudmFsdWU7IGlmICggdmFsdWUgPT09IHZvaWQgMCApIHZhbHVlID0gJyc7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgPT09IHNlbGVjdGlvbkVuZCkge1xuICAgICAgICAgICAgICAgIHZhciBjYXJldFBvc2l0aW9uID0gY29ycmVjdENhcmV0UG9zaXRpb24odmFsdWUsIHNlbGVjdGlvblN0YXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoY2FyZXRQb3NpdGlvbiAhPT0gc2VsZWN0aW9uU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0UGF0Y2hlZENhcmV0UG9zaXRpb24oZWwsIGNhcmV0UG9zaXRpb24sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvcnJlY3RDYXJldFBvc2l0aW9uSWZSZXF1aXJlZCgpO1xuICAgICAgICAvLyB0cnkgdG8gY29ycmVjdCBhZnRlciBzZWxlY3Rpb24gaGFzIHVwZGF0ZWQgYnkgYnJvd3NlclxuICAgICAgICAvLyB0aGlzIGNhc2UgaXMgcmVxdWlyZWQgd2hlbiB1c2VyIGNsaWNrcyBvbiBzb21lIHBvc2l0aW9uIHdoaWxlIGEgdGV4dCBpcyBzZWxlY3RlZCBvbiBpbnB1dFxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29ycmVjdENhcmV0UG9zaXRpb25JZlJlcXVpcmVkKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBvbk1vdXNlVXAoZSk7XG4gICAgICAgIHNldENhcmV0UG9zaXRpb25JbmZvQmVmb3JlQ2hhbmdlKGVsKTtcbiAgICB9O1xuICAgIHZhciBfb25Gb2N1cyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIC8vIFdvcmthcm91bmQgQ2hyb21lIGFuZCBTYWZhcmkgYnVnIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTc3OTMyOFxuICAgICAgICAvLyAob25Gb2N1cyBldmVudCB0YXJnZXQgc2VsZWN0aW9uU3RhcnQgaXMgYWx3YXlzIDAgYmVmb3JlIHNldFRpbWVvdXQpXG4gICAgICAgIGlmIChlLnBlcnNpc3QpXG4gICAgICAgICAgICB7IGUucGVyc2lzdCgpOyB9XG4gICAgICAgIHZhciBlbCA9IGUudGFyZ2V0O1xuICAgICAgICB2YXIgY3VycmVudFRhcmdldCA9IGUuY3VycmVudFRhcmdldDtcbiAgICAgICAgZm9jdXNlZEVsbS5jdXJyZW50ID0gZWw7XG4gICAgICAgIHRpbWVvdXQuY3VycmVudC5mb2N1c1RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb25TdGFydCA9IGVsLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbkVuZCA9IGVsLnNlbGVjdGlvbkVuZDtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGVsLnZhbHVlOyBpZiAoIHZhbHVlID09PSB2b2lkIDAgKSB2YWx1ZSA9ICcnO1xuICAgICAgICAgICAgdmFyIGNhcmV0UG9zaXRpb24gPSBjb3JyZWN0Q2FyZXRQb3NpdGlvbih2YWx1ZSwgc2VsZWN0aW9uU3RhcnQpO1xuICAgICAgICAgICAgLy9zZXRQYXRjaGVkQ2FyZXRQb3NpdGlvbiBvbmx5IHdoZW4gZXZlcnl0aGluZyBpcyBub3Qgc2VsZWN0ZWQgb24gZm9jdXMgKHdoaWxlIHRhYmJpbmcgaW50byB0aGUgZmllbGQpXG4gICAgICAgICAgICBpZiAoY2FyZXRQb3NpdGlvbiAhPT0gc2VsZWN0aW9uU3RhcnQgJiZcbiAgICAgICAgICAgICAgICAhKHNlbGVjdGlvblN0YXJ0ID09PSAwICYmIHNlbGVjdGlvbkVuZCA9PT0gdmFsdWUubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIHNldFBhdGNoZWRDYXJldFBvc2l0aW9uKGVsLCBjYXJldFBvc2l0aW9uLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbkZvY3VzKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZSksIHsgY3VycmVudFRhcmdldDogY3VycmVudFRhcmdldCB9KSk7XG4gICAgICAgIH0sIDApO1xuICAgIH07XG4gICAgdmFyIF9vbkJsdXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBmb2N1c2VkRWxtLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dC5jdXJyZW50LmZvY3VzVGltZW91dCk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0LmN1cnJlbnQuc2V0Q2FyZXRUaW1lb3V0KTtcbiAgICAgICAgb25CbHVyKGUpO1xuICAgIH07XG4gICAgLy8gYWRkIGlucHV0IG1vZGUgb24gZWxlbWVudCBiYXNlZCBvbiBmb3JtYXQgcHJvcCBhbmQgZGV2aWNlIG9uY2UgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkXG4gICAgdmFyIGlucHV0TW9kZSA9IG1vdW50ZWQgJiYgYWRkSW5wdXRNb2RlKCkgPyAnbnVtZXJpYycgOiB1bmRlZmluZWQ7XG4gICAgdmFyIGlucHV0UHJvcHMgPSBPYmplY3QuYXNzaWduKHsgaW5wdXRNb2RlOiBpbnB1dE1vZGUgfSwgb3RoZXJQcm9wcywge1xuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICB2YWx1ZTogZm9ybWF0dGVkVmFsdWUsXG4gICAgICAgIG9uQ2hhbmdlOiBfb25DaGFuZ2UsXG4gICAgICAgIG9uS2V5RG93bjogX29uS2V5RG93bixcbiAgICAgICAgb25Nb3VzZVVwOiBfb25Nb3VzZVVwLFxuICAgICAgICBvbkZvY3VzOiBfb25Gb2N1cyxcbiAgICAgICAgb25CbHVyOiBfb25CbHVyLFxuICAgIH0pO1xuICAgIGlmIChkaXNwbGF5VHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgIHJldHVybiByZW5kZXJUZXh0ID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIHJlbmRlclRleHQoZm9ybWF0dGVkVmFsdWUsIG90aGVyUHJvcHMpIHx8IG51bGwpKSA6IChSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBPYmplY3QuYXNzaWduKHt9LCBvdGhlclByb3BzLCB7IHJlZjogZ2V0SW5wdXRSZWYgfSksIGZvcm1hdHRlZFZhbHVlKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGN1c3RvbUlucHV0KSB7XG4gICAgICAgIHZhciBDdXN0b21JbnB1dCA9IGN1c3RvbUlucHV0O1xuICAgICAgICAvKiBAdHMtaWdub3JlICovXG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEN1c3RvbUlucHV0LCBPYmplY3QuYXNzaWduKHt9LCBpbnB1dFByb3BzLCB7IHJlZjogZ2V0SW5wdXRSZWYgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImlucHV0XCIsIE9iamVjdC5hc3NpZ24oe30sIGlucHV0UHJvcHMsIHsgcmVmOiBnZXRJbnB1dFJlZiB9KSk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdChudW1TdHIsIHByb3BzKSB7XG4gICAgdmFyIGRlY2ltYWxTY2FsZSA9IHByb3BzLmRlY2ltYWxTY2FsZTtcbiAgICB2YXIgZml4ZWREZWNpbWFsU2NhbGUgPSBwcm9wcy5maXhlZERlY2ltYWxTY2FsZTtcbiAgICB2YXIgcHJlZml4ID0gcHJvcHMucHJlZml4OyBpZiAoIHByZWZpeCA9PT0gdm9pZCAwICkgcHJlZml4ID0gJyc7XG4gICAgdmFyIHN1ZmZpeCA9IHByb3BzLnN1ZmZpeDsgaWYgKCBzdWZmaXggPT09IHZvaWQgMCApIHN1ZmZpeCA9ICcnO1xuICAgIHZhciBhbGxvd05lZ2F0aXZlID0gcHJvcHMuYWxsb3dOZWdhdGl2ZTtcbiAgICB2YXIgdGhvdXNhbmRzR3JvdXBTdHlsZSA9IHByb3BzLnRob3VzYW5kc0dyb3VwU3R5bGU7IGlmICggdGhvdXNhbmRzR3JvdXBTdHlsZSA9PT0gdm9pZCAwICkgdGhvdXNhbmRzR3JvdXBTdHlsZSA9ICd0aG91c2FuZCc7XG4gICAgLy8gZG9uJ3QgYXBwbHkgZm9ybWF0dGluZyBvbiBlbXB0eSBzdHJpbmcgb3IgJy0nXG4gICAgaWYgKG51bVN0ciA9PT0gJycgfHwgbnVtU3RyID09PSAnLScpIHtcbiAgICAgICAgcmV0dXJuIG51bVN0cjtcbiAgICB9XG4gICAgdmFyIHJlZiA9IGdldFNlcGFyYXRvcnMocHJvcHMpO1xuICAgIHZhciB0aG91c2FuZFNlcGFyYXRvciA9IHJlZi50aG91c2FuZFNlcGFyYXRvcjtcbiAgICB2YXIgZGVjaW1hbFNlcGFyYXRvciA9IHJlZi5kZWNpbWFsU2VwYXJhdG9yO1xuICAgIC8qKlxuICAgICAqIEtlZXAgdGhlIGRlY2ltYWwgc2VwYXJhdG9yXG4gICAgICogd2hlbiBkZWNpbWFsU2NhbGUgaXMgbm90IGRlZmluZWQgb3Igbm9uIHplcm8gYW5kIHRoZSBudW1TdHIgaGFzIGRlY2ltYWwgaW4gaXRcbiAgICAgKiBPciBpZiBkZWNpbWFsU2NhbGUgaXMgPiAwIGFuZCBmaXhlRGVjaW1hbFNjYWxlIGlzIHRydWUgKGV2ZW4gaWYgbnVtU3RyIGhhcyBubyBkZWNpbWFsKVxuICAgICAqL1xuICAgIHZhciBoYXNEZWNpbWFsU2VwYXJhdG9yID0gKGRlY2ltYWxTY2FsZSAhPT0gMCAmJiBudW1TdHIuaW5kZXhPZignLicpICE9PSAtMSkgfHwgKGRlY2ltYWxTY2FsZSAmJiBmaXhlZERlY2ltYWxTY2FsZSk7XG4gICAgdmFyIHJlZiQxID0gc3BsaXREZWNpbWFsKG51bVN0ciwgYWxsb3dOZWdhdGl2ZSk7XG4gICAgdmFyIGJlZm9yZURlY2ltYWwgPSByZWYkMS5iZWZvcmVEZWNpbWFsO1xuICAgIHZhciBhZnRlckRlY2ltYWwgPSByZWYkMS5hZnRlckRlY2ltYWw7XG4gICAgdmFyIGFkZE5lZ2F0aW9uID0gcmVmJDEuYWRkTmVnYXRpb247IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJlZmVyLWNvbnN0XG4gICAgLy9hcHBseSBkZWNpbWFsIHByZWNpc2lvbiBpZiBpdHMgZGVmaW5lZFxuICAgIGlmIChkZWNpbWFsU2NhbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhZnRlckRlY2ltYWwgPSBsaW1pdFRvU2NhbGUoYWZ0ZXJEZWNpbWFsLCBkZWNpbWFsU2NhbGUsICEhZml4ZWREZWNpbWFsU2NhbGUpO1xuICAgIH1cbiAgICBpZiAodGhvdXNhbmRTZXBhcmF0b3IpIHtcbiAgICAgICAgYmVmb3JlRGVjaW1hbCA9IGFwcGx5VGhvdXNhbmRTZXBhcmF0b3IoYmVmb3JlRGVjaW1hbCwgdGhvdXNhbmRTZXBhcmF0b3IsIHRob3VzYW5kc0dyb3VwU3R5bGUpO1xuICAgIH1cbiAgICAvL2FkZCBwcmVmaXggYW5kIHN1ZmZpeCB3aGVuIHRoZXJlIGlzIGEgbnVtYmVyIHByZXNlbnRcbiAgICBpZiAocHJlZml4KVxuICAgICAgICB7IGJlZm9yZURlY2ltYWwgPSBwcmVmaXggKyBiZWZvcmVEZWNpbWFsOyB9XG4gICAgaWYgKHN1ZmZpeClcbiAgICAgICAgeyBhZnRlckRlY2ltYWwgPSBhZnRlckRlY2ltYWwgKyBzdWZmaXg7IH1cbiAgICAvL3Jlc3RvcmUgbmVnYXRpb24gc2lnblxuICAgIGlmIChhZGROZWdhdGlvbilcbiAgICAgICAgeyBiZWZvcmVEZWNpbWFsID0gJy0nICsgYmVmb3JlRGVjaW1hbDsgfVxuICAgIG51bVN0ciA9IGJlZm9yZURlY2ltYWwgKyAoKGhhc0RlY2ltYWxTZXBhcmF0b3IgJiYgZGVjaW1hbFNlcGFyYXRvcikgfHwgJycpICsgYWZ0ZXJEZWNpbWFsO1xuICAgIHJldHVybiBudW1TdHI7XG59XG5mdW5jdGlvbiBnZXRTZXBhcmF0b3JzKHByb3BzKSB7XG4gICAgdmFyIGRlY2ltYWxTZXBhcmF0b3IgPSBwcm9wcy5kZWNpbWFsU2VwYXJhdG9yOyBpZiAoIGRlY2ltYWxTZXBhcmF0b3IgPT09IHZvaWQgMCApIGRlY2ltYWxTZXBhcmF0b3IgPSAnLic7XG4gICAgdmFyIHRob3VzYW5kU2VwYXJhdG9yID0gcHJvcHMudGhvdXNhbmRTZXBhcmF0b3I7XG4gICAgdmFyIGFsbG93ZWREZWNpbWFsU2VwYXJhdG9ycyA9IHByb3BzLmFsbG93ZWREZWNpbWFsU2VwYXJhdG9ycztcbiAgICBpZiAodGhvdXNhbmRTZXBhcmF0b3IgPT09IHRydWUpIHtcbiAgICAgICAgdGhvdXNhbmRTZXBhcmF0b3IgPSAnLCc7XG4gICAgfVxuICAgIGlmICghYWxsb3dlZERlY2ltYWxTZXBhcmF0b3JzKSB7XG4gICAgICAgIGFsbG93ZWREZWNpbWFsU2VwYXJhdG9ycyA9IFtkZWNpbWFsU2VwYXJhdG9yLCAnLiddO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBkZWNpbWFsU2VwYXJhdG9yOiBkZWNpbWFsU2VwYXJhdG9yLFxuICAgICAgICB0aG91c2FuZFNlcGFyYXRvcjogdGhvdXNhbmRTZXBhcmF0b3IsXG4gICAgICAgIGFsbG93ZWREZWNpbWFsU2VwYXJhdG9yczogYWxsb3dlZERlY2ltYWxTZXBhcmF0b3JzLFxuICAgIH07XG59XG5mdW5jdGlvbiBoYW5kbGVOZWdhdGlvbih2YWx1ZSwgYWxsb3dOZWdhdGl2ZSkge1xuICAgIGlmICggdmFsdWUgPT09IHZvaWQgMCApIHZhbHVlID0gJyc7XG5cbiAgICB2YXIgbmVnYXRpb25SZWdleCA9IG5ldyBSZWdFeHAoJygtKScpO1xuICAgIHZhciBkb3VibGVOZWdhdGlvblJlZ2V4ID0gbmV3IFJlZ0V4cCgnKC0pKC4pKigtKScpO1xuICAgIC8vIENoZWNrIG51bWJlciBoYXMgJy0nIHZhbHVlXG4gICAgdmFyIGhhc05lZ2F0aW9uID0gbmVnYXRpb25SZWdleC50ZXN0KHZhbHVlKTtcbiAgICAvLyBDaGVjayBudW1iZXIgaGFzIDIgb3IgbW9yZSAnLScgdmFsdWVzXG4gICAgdmFyIHJlbW92ZU5lZ2F0aW9uID0gZG91YmxlTmVnYXRpb25SZWdleC50ZXN0KHZhbHVlKTtcbiAgICAvL3JlbW92ZSBuZWdhdGlvblxuICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvLS9nLCAnJyk7XG4gICAgaWYgKGhhc05lZ2F0aW9uICYmICFyZW1vdmVOZWdhdGlvbiAmJiBhbGxvd05lZ2F0aXZlKSB7XG4gICAgICAgIHZhbHVlID0gJy0nICsgdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGdldE51bWJlclJlZ2V4KGRlY2ltYWxTZXBhcmF0b3IsIGdsb2JhbCkge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKChcIiheLSl8WzAtOV18XCIgKyAoZXNjYXBlUmVnRXhwKGRlY2ltYWxTZXBhcmF0b3IpKSksIGdsb2JhbCA/ICdnJyA6IHVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiBpc051bWVyaWNTdHJpbmcodmFsLCBwcmVmaXgsIHN1ZmZpeCkge1xuICAgIC8vIGZvciBlbXB0eSB2YWx1ZSB3ZSBjYW4gYWx3YXlzIHRyZWF0IGl0IGFzIG51bWVyaWMgc3RyaW5nXG4gICAgaWYgKHZhbCA9PT0gJycpXG4gICAgICAgIHsgcmV0dXJuIHRydWU7IH1cbiAgICByZXR1cm4gKCEocHJlZml4ID09PSBudWxsIHx8IHByZWZpeCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJlZml4Lm1hdGNoKC9cXGQvKSkgJiYgIShzdWZmaXggPT09IG51bGwgfHwgc3VmZml4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdWZmaXgubWF0Y2goL1xcZC8pKSAmJiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyAmJiAhaXNOYU4oTnVtYmVyKHZhbCkpKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUZvcm1hdHRpbmcodmFsdWUsIGNoYW5nZU1ldGEsIHByb3BzKSB7XG4gICAgdmFyIGFzc2lnbjtcblxuICAgIGlmICggY2hhbmdlTWV0YSA9PT0gdm9pZCAwICkgY2hhbmdlTWV0YSA9IGdldERlZmF1bHRDaGFuZ2VNZXRhKHZhbHVlKTtcbiAgICB2YXIgYWxsb3dOZWdhdGl2ZSA9IHByb3BzLmFsbG93TmVnYXRpdmU7XG4gICAgdmFyIHByZWZpeCA9IHByb3BzLnByZWZpeDsgaWYgKCBwcmVmaXggPT09IHZvaWQgMCApIHByZWZpeCA9ICcnO1xuICAgIHZhciBzdWZmaXggPSBwcm9wcy5zdWZmaXg7IGlmICggc3VmZml4ID09PSB2b2lkIDAgKSBzdWZmaXggPSAnJztcbiAgICB2YXIgZGVjaW1hbFNjYWxlID0gcHJvcHMuZGVjaW1hbFNjYWxlO1xuICAgIHZhciBmcm9tID0gY2hhbmdlTWV0YS5mcm9tO1xuICAgIHZhciB0byA9IGNoYW5nZU1ldGEudG87XG4gICAgdmFyIHN0YXJ0ID0gdG8uc3RhcnQ7XG4gICAgdmFyIGVuZCA9IHRvLmVuZDtcbiAgICB2YXIgcmVmID0gZ2V0U2VwYXJhdG9ycyhwcm9wcyk7XG4gICAgdmFyIGFsbG93ZWREZWNpbWFsU2VwYXJhdG9ycyA9IHJlZi5hbGxvd2VkRGVjaW1hbFNlcGFyYXRvcnM7XG4gICAgdmFyIGRlY2ltYWxTZXBhcmF0b3IgPSByZWYuZGVjaW1hbFNlcGFyYXRvcjtcbiAgICB2YXIgaXNCZWZvcmVEZWNpbWFsU2VwYXJhdG9yID0gdmFsdWVbZW5kXSA9PT0gZGVjaW1hbFNlcGFyYXRvcjtcbiAgICAvKipcbiAgICAgKiBJZiBvbmx5IGEgbnVtYmVyIGlzIGFkZGVkIG9uIGVtcHR5IGlucHV0IHdoaWNoIG1hdGNoZXMgd2l0aCB0aGUgcHJlZml4IG9yIHN1ZmZpeCxcbiAgICAgKiB0aGVuIGRvbid0IHJlbW92ZSBpdCwganVzdCByZXR1cm4gdGhlIHNhbWVcbiAgICAgKi9cbiAgICBpZiAoY2hhcklzTnVtYmVyKHZhbHVlKSAmJlxuICAgICAgICAodmFsdWUgPT09IHByZWZpeCB8fCB2YWx1ZSA9PT0gc3VmZml4KSAmJlxuICAgICAgICBjaGFuZ2VNZXRhLmxhc3RWYWx1ZSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICAvKiogQ2hlY2sgZm9yIGFueSBhbGxvd2VkIGRlY2ltYWwgc2VwYXJhdG9yIGlzIGFkZGVkIGluIHRoZSBudW1lcmljIGZvcm1hdCBhbmQgcmVwbGFjZSBpdCB3aXRoIGRlY2ltYWwgc2VwYXJhdG9yICovXG4gICAgaWYgKGVuZCAtIHN0YXJ0ID09PSAxICYmIGFsbG93ZWREZWNpbWFsU2VwYXJhdG9ycy5pbmRleE9mKHZhbHVlW3N0YXJ0XSkgIT09IC0xKSB7XG4gICAgICAgIHZhciBzZXBhcmF0b3IgPSBkZWNpbWFsU2NhbGUgPT09IDAgPyAnJyA6IGRlY2ltYWxTZXBhcmF0b3I7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDAsIHN0YXJ0KSArIHNlcGFyYXRvciArIHZhbHVlLnN1YnN0cmluZyhzdGFydCArIDEsIHZhbHVlLmxlbmd0aCk7XG4gICAgfVxuICAgIHZhciBzdHJpcE5lZ2F0aW9uID0gZnVuY3Rpb24gKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpZiBwcmVmaXggc3RhcnRzIHdpdGggLSB3ZSBkb24ndCBhbGxvdyBuZWdhdGl2ZSBudW1iZXIgdG8gYXZvaWQgY29uZnVzaW9uXG4gICAgICAgICAqIGlmIHN1ZmZpeCBzdGFydHMgd2l0aCAtIGFuZCB0aGUgdmFsdWUgbGVuZ3RoIGlzIHNhbWUgYXMgc3VmZml4IGxlbmd0aCwgdGhlbiB0aGUgLSBzaWduIGlzIGZyb20gdGhlIHN1ZmZpeFxuICAgICAgICAgKiBJbiBvdGhlciBjYXNlcywgaWYgdGhlIHZhbHVlIHN0YXJ0cyB3aXRoIC0gdGhlbiBpdCBpcyBhIG5lZ2F0aW9uXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgaGFzTmVnYXRpb24gPSBmYWxzZTtcbiAgICAgICAgdmFyIGhhc0RvdWJsZU5lZ2F0aW9uID0gZmFsc2U7XG4gICAgICAgIGlmIChwcmVmaXguc3RhcnRzV2l0aCgnLScpKSB7XG4gICAgICAgICAgICBoYXNOZWdhdGlvbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoJy0tJykpIHtcbiAgICAgICAgICAgIGhhc05lZ2F0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICBoYXNEb3VibGVOZWdhdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3VmZml4LnN0YXJ0c1dpdGgoJy0nKSAmJiB2YWx1ZS5sZW5ndGggPT09IHN1ZmZpeC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGhhc05lZ2F0aW9uID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWVbMF0gPT09ICctJykge1xuICAgICAgICAgICAgaGFzTmVnYXRpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFyc1RvUmVtb3ZlID0gaGFzTmVnYXRpb24gPyAxIDogMDtcbiAgICAgICAgaWYgKGhhc0RvdWJsZU5lZ2F0aW9uKVxuICAgICAgICAgICAgeyBjaGFyc1RvUmVtb3ZlID0gMjsgfVxuICAgICAgICAvLyByZW1vdmUgbmVnYXRpb24vZG91YmxlIG5lZ2F0aW9uIGZyb20gc3RhcnQgdG8gc2ltcGxpZnkgcHJlZml4IGxvZ2ljIGFzIG5lZ2F0aW9uIGNvbWVzIGJlZm9yZSBwcmVmaXhcbiAgICAgICAgaWYgKGNoYXJzVG9SZW1vdmUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKGNoYXJzVG9SZW1vdmUpO1xuICAgICAgICAgICAgLy8gYWNjb3VudCBmb3IgdGhlIHJlbW92YWwgb2YgdGhlIG5lZ2F0aW9uIGZvciBzdGFydCBhbmQgZW5kIGluZGV4XG4gICAgICAgICAgICBzdGFydCAtPSBjaGFyc1RvUmVtb3ZlO1xuICAgICAgICAgICAgZW5kIC09IGNoYXJzVG9SZW1vdmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBzdGFydDogc3RhcnQsIGVuZDogZW5kLCBoYXNOZWdhdGlvbjogaGFzTmVnYXRpb24gfTtcbiAgICB9O1xuICAgIHZhciB0b01ldGFkYXRhID0gc3RyaXBOZWdhdGlvbih2YWx1ZSwgc3RhcnQsIGVuZCk7XG4gICAgdmFyIGhhc05lZ2F0aW9uID0gdG9NZXRhZGF0YS5oYXNOZWdhdGlvbjtcbiAgICAoKGFzc2lnbiA9IHRvTWV0YWRhdGEsIHZhbHVlID0gYXNzaWduLnZhbHVlLCBzdGFydCA9IGFzc2lnbi5zdGFydCwgZW5kID0gYXNzaWduLmVuZCkpO1xuICAgIHZhciByZWYkMSA9IHN0cmlwTmVnYXRpb24oY2hhbmdlTWV0YS5sYXN0VmFsdWUsIGZyb20uc3RhcnQsIGZyb20uZW5kKTtcbiAgICB2YXIgZnJvbVN0YXJ0ID0gcmVmJDEuc3RhcnQ7XG4gICAgdmFyIGZyb21FbmQgPSByZWYkMS5lbmQ7XG4gICAgdmFyIGxhc3RWYWx1ZSA9IHJlZiQxLnZhbHVlO1xuICAgIC8vIGlmIG9ubHkgcHJlZml4IGFuZCBzdWZmaXggcGFydCBpcyB1cGRhdGVkIHJlc2V0IHRoZSB2YWx1ZSB0byBsYXN0IHZhbHVlXG4gICAgLy8gaWYgdGhlIGNoYW5nZWQgcmFuZ2UgaXMgZnJvbSBzdWZmaXggaW4gdGhlIHVwZGF0ZWQgdmFsdWUsIGFuZCB0aGUgdGhlIHN1ZmZpeCBzdGFydHMgd2l0aCB0aGUgc2FtZSBjaGFyYWN0ZXJzLCBhbGxvdyB0aGUgY2hhbmdlXG4gICAgdmFyIHVwZGF0ZWRTdWZmaXhQYXJ0ID0gdmFsdWUuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpO1xuICAgIGlmICh2YWx1ZS5sZW5ndGggJiZcbiAgICAgICAgbGFzdFZhbHVlLmxlbmd0aCAmJlxuICAgICAgICAoZnJvbVN0YXJ0ID4gbGFzdFZhbHVlLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGggfHwgZnJvbUVuZCA8IHByZWZpeC5sZW5ndGgpICYmXG4gICAgICAgICEodXBkYXRlZFN1ZmZpeFBhcnQgJiYgc3VmZml4LnN0YXJ0c1dpdGgodXBkYXRlZFN1ZmZpeFBhcnQpKSkge1xuICAgICAgICB2YWx1ZSA9IGxhc3RWYWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogcmVtb3ZlIHByZWZpeFxuICAgICAqIFJlbW92ZSB3aG9sZSBwcmVmaXggcGFydCBpZiBpdHMgcHJlc2VudCBvbiB0aGUgdmFsdWVcbiAgICAgKiBJZiB0aGUgcHJlZml4IGlzIHBhcnRpYWxseSBkZWxldGVkIChpbiB3aGljaCBjYXNlIGNoYW5nZSBzdGFydCBpbmRleCB3aWxsIGJlIGxlc3MgdGhlIHByZWZpeCBsZW5ndGgpXG4gICAgICogUmVtb3ZlIG9ubHkgcGFydGlhbCBwYXJ0IG9mIHByZWZpeC5cbiAgICAgKi9cbiAgICB2YXIgc3RhcnRJbmRleCA9IDA7XG4gICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgocHJlZml4KSlcbiAgICAgICAgeyBzdGFydEluZGV4ICs9IHByZWZpeC5sZW5ndGg7IH1cbiAgICBlbHNlIGlmIChzdGFydCA8IHByZWZpeC5sZW5ndGgpXG4gICAgICAgIHsgc3RhcnRJbmRleCA9IHN0YXJ0OyB9XG4gICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoc3RhcnRJbmRleCk7XG4gICAgLy8gYWNjb3VudCBmb3IgZGVsZXRlZCBwcmVmaXggZm9yIGVuZFxuICAgIGVuZCAtPSBzdGFydEluZGV4O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBzdWZmaXhcbiAgICAgKiBSZW1vdmUgd2hvbGUgc3VmZml4IHBhcnQgaWYgaXRzIHByZXNlbnQgb24gdGhlIHZhbHVlXG4gICAgICogSWYgdGhlIHN1ZmZpeCBpcyBwYXJ0aWFsbHkgZGVsZXRlZCAoaW4gd2hpY2ggY2FzZSBjaGFuZ2UgZW5kIGluZGV4IHdpbGwgYmUgZ3JlYXRlciB0aGFuIHRoZSBzdWZmaXhTdGFydEluZGV4KVxuICAgICAqIHJlbW92ZSB0aGUgcGFydGlhbCBwYXJ0IG9mIHN1ZmZpeFxuICAgICAqL1xuICAgIHZhciBlbmRJbmRleCA9IHZhbHVlLmxlbmd0aDtcbiAgICB2YXIgc3VmZml4U3RhcnRJbmRleCA9IHZhbHVlLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGg7XG4gICAgaWYgKHZhbHVlLmVuZHNXaXRoKHN1ZmZpeCkpXG4gICAgICAgIHsgZW5kSW5kZXggPSBzdWZmaXhTdGFydEluZGV4OyB9XG4gICAgLy8gaWYgdGhlIHN1ZmZpeCBpcyByZW1vdmVkIGZyb20gdGhlIGVuZFxuICAgIGVsc2UgaWYgKGVuZCA+IHN1ZmZpeFN0YXJ0SW5kZXgpXG4gICAgICAgIHsgZW5kSW5kZXggPSBlbmQ7IH1cbiAgICAvLyBpZiB0aGUgc3VmZml4IGlzIHJlbW92ZWQgZnJvbSBzdGFydFxuICAgIGVsc2UgaWYgKGVuZCA+IHZhbHVlLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGgpXG4gICAgICAgIHsgZW5kSW5kZXggPSBlbmQ7IH1cbiAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygwLCBlbmRJbmRleCk7XG4gICAgLy8gYWRkIHRoZSBuZWdhdGlvbiBiYWNrIGFuZCBoYW5kbGUgZm9yIGRvdWJsZSBuZWdhdGlvblxuICAgIHZhbHVlID0gaGFuZGxlTmVnYXRpb24oaGFzTmVnYXRpb24gPyAoXCItXCIgKyB2YWx1ZSkgOiB2YWx1ZSwgYWxsb3dOZWdhdGl2ZSk7XG4gICAgLy8gcmVtb3ZlIG5vbiBudW1lcmljIGNoYXJhY3RlcnNcbiAgICB2YWx1ZSA9ICh2YWx1ZS5tYXRjaChnZXROdW1iZXJSZWdleChkZWNpbWFsU2VwYXJhdG9yLCB0cnVlKSkgfHwgW10pLmpvaW4oJycpO1xuICAgIC8vIHJlcGxhY2UgdGhlIGRlY2ltYWxTZXBhcmF0b3Igd2l0aCAuLCBhbmQgb25seSBrZWVwIHRoZSBmaXJzdCBzZXBhcmF0b3IsIGlnbm9yZSBmb2xsb3dpbmcgb25lc1xuICAgIHZhciBmaXJzdEluZGV4ID0gdmFsdWUuaW5kZXhPZihkZWNpbWFsU2VwYXJhdG9yKTtcbiAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UobmV3IFJlZ0V4cChlc2NhcGVSZWdFeHAoZGVjaW1hbFNlcGFyYXRvciksICdnJyksIGZ1bmN0aW9uIChtYXRjaCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4ID09PSBmaXJzdEluZGV4ID8gJy4nIDogJyc7XG4gICAgfSk7XG4gICAgLy9jaGVjayBpZiBiZWZvcmVEZWNpbWFsIGdvdCBkZWxldGVkIGFuZCB0aGVyZSBpcyBub3RoaW5nIGFmdGVyIGRlY2ltYWwsXG4gICAgLy9jbGVhciBhbGwgbnVtYmVycyBpbiBzdWNoIGNhc2Ugd2hpbGUga2VlcGluZyB0aGUgLSBzaWduXG4gICAgdmFyIHJlZiQyID0gc3BsaXREZWNpbWFsKHZhbHVlLCBhbGxvd05lZ2F0aXZlKTtcbiAgICB2YXIgYmVmb3JlRGVjaW1hbCA9IHJlZiQyLmJlZm9yZURlY2ltYWw7XG4gICAgdmFyIGFmdGVyRGVjaW1hbCA9IHJlZiQyLmFmdGVyRGVjaW1hbDtcbiAgICB2YXIgYWRkTmVnYXRpb24gPSByZWYkMi5hZGROZWdhdGlvbjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItY29uc3RcbiAgICAvL2NsZWFyIG9ubHkgaWYgc29tZXRoaW5nIGdvdCBkZWxldGVkIGJlZm9yZSBkZWNpbWFsIChjdXJzb3IgaXMgYmVmb3JlIGRlY2ltYWwpXG4gICAgaWYgKHRvLmVuZCAtIHRvLnN0YXJ0IDwgZnJvbS5lbmQgLSBmcm9tLnN0YXJ0ICYmXG4gICAgICAgIGJlZm9yZURlY2ltYWwgPT09ICcnICYmXG4gICAgICAgIGlzQmVmb3JlRGVjaW1hbFNlcGFyYXRvciAmJlxuICAgICAgICAhcGFyc2VGbG9hdChhZnRlckRlY2ltYWwpKSB7XG4gICAgICAgIHZhbHVlID0gYWRkTmVnYXRpb24gPyAnLScgOiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0Q2FyZXRCb3VuZGFyeShmb3JtYXR0ZWRWYWx1ZSwgcHJvcHMpIHtcbiAgICB2YXIgcHJlZml4ID0gcHJvcHMucHJlZml4OyBpZiAoIHByZWZpeCA9PT0gdm9pZCAwICkgcHJlZml4ID0gJyc7XG4gICAgdmFyIHN1ZmZpeCA9IHByb3BzLnN1ZmZpeDsgaWYgKCBzdWZmaXggPT09IHZvaWQgMCApIHN1ZmZpeCA9ICcnO1xuICAgIHZhciBib3VuZGFyeUFyeSA9IEFycmF5LmZyb20oeyBsZW5ndGg6IGZvcm1hdHRlZFZhbHVlLmxlbmd0aCArIDEgfSkubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH0pO1xuICAgIHZhciBoYXNOZWdhdGlvbiA9IGZvcm1hdHRlZFZhbHVlWzBdID09PSAnLSc7XG4gICAgLy8gZmlsbCBmb3IgcHJlZml4IGFuZCBuZWdhdGlvblxuICAgIGJvdW5kYXJ5QXJ5LmZpbGwoZmFsc2UsIDAsIHByZWZpeC5sZW5ndGggKyAoaGFzTmVnYXRpb24gPyAxIDogMCkpO1xuICAgIC8vIGZpbGwgZm9yIHN1ZmZpeFxuICAgIHZhciB2YWxMbiA9IGZvcm1hdHRlZFZhbHVlLmxlbmd0aDtcbiAgICBib3VuZGFyeUFyeS5maWxsKGZhbHNlLCB2YWxMbiAtIHN1ZmZpeC5sZW5ndGggKyAxLCB2YWxMbiArIDEpO1xuICAgIHJldHVybiBib3VuZGFyeUFyeTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQW5kVXBkYXRlUHJvcHMocHJvcHMpIHtcbiAgICB2YXIgcmVmID0gZ2V0U2VwYXJhdG9ycyhwcm9wcyk7XG4gICAgdmFyIHRob3VzYW5kU2VwYXJhdG9yID0gcmVmLnRob3VzYW5kU2VwYXJhdG9yO1xuICAgIHZhciBkZWNpbWFsU2VwYXJhdG9yID0gcmVmLmRlY2ltYWxTZXBhcmF0b3I7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICAgIHZhciBwcmVmaXggPSBwcm9wcy5wcmVmaXg7IGlmICggcHJlZml4ID09PSB2b2lkIDAgKSBwcmVmaXggPSAnJztcbiAgICB2YXIgYWxsb3dOZWdhdGl2ZSA9IHByb3BzLmFsbG93TmVnYXRpdmU7IGlmICggYWxsb3dOZWdhdGl2ZSA9PT0gdm9pZCAwICkgYWxsb3dOZWdhdGl2ZSA9IHRydWU7XG4gICAgaWYgKHRob3VzYW5kU2VwYXJhdG9yID09PSBkZWNpbWFsU2VwYXJhdG9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigoXCJcXG4gICAgICAgIERlY2ltYWwgc2VwYXJhdG9yIGNhbid0IGJlIHNhbWUgYXMgdGhvdXNhbmQgc2VwYXJhdG9yLlxcbiAgICAgICAgdGhvdXNhbmRTZXBhcmF0b3I6IFwiICsgdGhvdXNhbmRTZXBhcmF0b3IgKyBcIiAodGhvdXNhbmRTZXBhcmF0b3IgPSB7dHJ1ZX0gaXMgc2FtZSBhcyB0aG91c2FuZFNlcGFyYXRvciA9IFxcXCIsXFxcIilcXG4gICAgICAgIGRlY2ltYWxTZXBhcmF0b3I6IFwiICsgZGVjaW1hbFNlcGFyYXRvciArIFwiIChkZWZhdWx0IHZhbHVlIGZvciBkZWNpbWFsU2VwYXJhdG9yIGlzIC4pXFxuICAgICBcIikpO1xuICAgIH1cbiAgICBpZiAocHJlZml4LnN0YXJ0c1dpdGgoJy0nKSAmJiBhbGxvd05lZ2F0aXZlKSB7XG4gICAgICAgIC8vIFRPRE86IHRocm93IGVycm9yIGluIG5leHQgbWFqb3IgdmVyc2lvblxuICAgICAgICBjb25zb2xlLmVycm9yKChcIlxcbiAgICAgIFByZWZpeCBjYW4ndCBzdGFydCB3aXRoICctJyB3aGVuIGFsbG93TmVnYXRpdmUgaXMgdHJ1ZS5cXG4gICAgICBwcmVmaXg6IFwiICsgcHJlZml4ICsgXCJcXG4gICAgICBhbGxvd05lZ2F0aXZlOiBcIiArIGFsbG93TmVnYXRpdmUgKyBcIlxcbiAgICBcIikpO1xuICAgICAgICBhbGxvd05lZ2F0aXZlID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSwgeyBhbGxvd05lZ2F0aXZlOiBhbGxvd05lZ2F0aXZlIH0pO1xufVxuZnVuY3Rpb24gdXNlTnVtZXJpY0Zvcm1hdChwcm9wcykge1xuICAgIC8vIHZhbGlkYXRlIHByb3BzXG4gICAgcHJvcHMgPSB2YWxpZGF0ZUFuZFVwZGF0ZVByb3BzKHByb3BzKTtcbiAgICB2YXIgX2RlY2ltYWxTZXBhcmF0b3IgPSBwcm9wcy5kZWNpbWFsU2VwYXJhdG9yO1xuICAgIHZhciBfYWxsb3dlZERlY2ltYWxTZXBhcmF0b3JzID0gcHJvcHMuYWxsb3dlZERlY2ltYWxTZXBhcmF0b3JzO1xuICAgIHZhciB0aG91c2FuZHNHcm91cFN0eWxlID0gcHJvcHMudGhvdXNhbmRzR3JvdXBTdHlsZTtcbiAgICB2YXIgc3VmZml4ID0gcHJvcHMuc3VmZml4O1xuICAgIHZhciBhbGxvd05lZ2F0aXZlID0gcHJvcHMuYWxsb3dOZWdhdGl2ZTtcbiAgICB2YXIgYWxsb3dMZWFkaW5nWmVyb3MgPSBwcm9wcy5hbGxvd0xlYWRpbmdaZXJvcztcbiAgICB2YXIgb25LZXlEb3duID0gcHJvcHMub25LZXlEb3duOyBpZiAoIG9uS2V5RG93biA9PT0gdm9pZCAwICkgb25LZXlEb3duID0gbm9vcDtcbiAgICB2YXIgb25CbHVyID0gcHJvcHMub25CbHVyOyBpZiAoIG9uQmx1ciA9PT0gdm9pZCAwICkgb25CbHVyID0gbm9vcDtcbiAgICB2YXIgdGhvdXNhbmRTZXBhcmF0b3IgPSBwcm9wcy50aG91c2FuZFNlcGFyYXRvcjtcbiAgICB2YXIgZGVjaW1hbFNjYWxlID0gcHJvcHMuZGVjaW1hbFNjYWxlO1xuICAgIHZhciBmaXhlZERlY2ltYWxTY2FsZSA9IHByb3BzLmZpeGVkRGVjaW1hbFNjYWxlO1xuICAgIHZhciBwcmVmaXggPSBwcm9wcy5wcmVmaXg7IGlmICggcHJlZml4ID09PSB2b2lkIDAgKSBwcmVmaXggPSAnJztcbiAgICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuICAgIHZhciB2YWx1ZUlzTnVtZXJpY1N0cmluZyA9IHByb3BzLnZhbHVlSXNOdW1lcmljU3RyaW5nO1xuICAgIHZhciBvblZhbHVlQ2hhbmdlID0gcHJvcHMub25WYWx1ZUNoYW5nZTtcbiAgICB2YXIgcmVzdFByb3BzID0gX19yZXN0KHByb3BzLCBbXCJkZWNpbWFsU2VwYXJhdG9yXCIsIFwiYWxsb3dlZERlY2ltYWxTZXBhcmF0b3JzXCIsIFwidGhvdXNhbmRzR3JvdXBTdHlsZVwiLCBcInN1ZmZpeFwiLCBcImFsbG93TmVnYXRpdmVcIiwgXCJhbGxvd0xlYWRpbmdaZXJvc1wiLCBcIm9uS2V5RG93blwiLCBcIm9uQmx1clwiLCBcInRob3VzYW5kU2VwYXJhdG9yXCIsIFwiZGVjaW1hbFNjYWxlXCIsIFwiZml4ZWREZWNpbWFsU2NhbGVcIiwgXCJwcmVmaXhcIiwgXCJkZWZhdWx0VmFsdWVcIiwgXCJ2YWx1ZVwiLCBcInZhbHVlSXNOdW1lcmljU3RyaW5nXCIsIFwib25WYWx1ZUNoYW5nZVwiXSk7XG4gICAgLy8gZ2V0IGRlcml2ZWQgZGVjaW1hbFNlcGFyYXRvciBhbmQgYWxsb3dlZERlY2ltYWxTZXBhcmF0b3JzXG4gICAgdmFyIHJlZiA9IGdldFNlcGFyYXRvcnMocHJvcHMpO1xuICAgIHZhciBkZWNpbWFsU2VwYXJhdG9yID0gcmVmLmRlY2ltYWxTZXBhcmF0b3I7XG4gICAgdmFyIGFsbG93ZWREZWNpbWFsU2VwYXJhdG9ycyA9IHJlZi5hbGxvd2VkRGVjaW1hbFNlcGFyYXRvcnM7XG4gICAgdmFyIF9mb3JtYXQgPSBmdW5jdGlvbiAobnVtU3RyKSB7IHJldHVybiBmb3JtYXQobnVtU3RyLCBwcm9wcyk7IH07XG4gICAgdmFyIF9yZW1vdmVGb3JtYXR0aW5nID0gZnVuY3Rpb24gKGlucHV0VmFsdWUsIGNoYW5nZU1ldGEpIHsgcmV0dXJuIHJlbW92ZUZvcm1hdHRpbmcoaW5wdXRWYWx1ZSwgY2hhbmdlTWV0YSwgcHJvcHMpOyB9O1xuICAgIHZhciBfdmFsdWUgPSBpc05pbCh2YWx1ZSkgPyBkZWZhdWx0VmFsdWUgOiB2YWx1ZTtcbiAgICAvLyB0cnkgdG8gZmlndXJlIG91dCBpc1ZhbHVlTnVtZXJpY1N0cmluZyBiYXNlZCBvbiBmb3JtYXQgcHJvcCBhbmQgdmFsdWVcbiAgICB2YXIgX3ZhbHVlSXNOdW1lcmljU3RyaW5nID0gdmFsdWVJc051bWVyaWNTdHJpbmcgIT09IG51bGwgJiYgdmFsdWVJc051bWVyaWNTdHJpbmcgIT09IHZvaWQgMCA/IHZhbHVlSXNOdW1lcmljU3RyaW5nIDogaXNOdW1lcmljU3RyaW5nKF92YWx1ZSwgcHJlZml4LCBzdWZmaXgpO1xuICAgIGlmICghaXNOaWwodmFsdWUpKSB7XG4gICAgICAgIF92YWx1ZUlzTnVtZXJpY1N0cmluZyA9IF92YWx1ZUlzTnVtZXJpY1N0cmluZyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xuICAgIH1cbiAgICBlbHNlIGlmICghaXNOaWwoZGVmYXVsdFZhbHVlKSkge1xuICAgICAgICBfdmFsdWVJc051bWVyaWNTdHJpbmcgPSBfdmFsdWVJc051bWVyaWNTdHJpbmcgfHwgdHlwZW9mIGRlZmF1bHRWYWx1ZSA9PT0gJ251bWJlcic7XG4gICAgfVxuICAgIHZhciByb3VuZEluY29taW5nVmFsdWVUb1ByZWNpc2lvbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoaXNOb3RWYWxpZFZhbHVlKHZhbHVlKSlcbiAgICAgICAgICAgIHsgcmV0dXJuIHZhbHVlOyB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRvTnVtZXJpY1N0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG9ubHkgcm91bmQgbnVtZXJpYyBvciBmbG9hdCBzdHJpbmcgdmFsdWVzIGNvbWluZyB0aHJvdWdoIHByb3BzLFxuICAgICAgICAgKiB3ZSBkb24ndCBuZWVkIHRvIGRvIGl0IGZvciBvbkNoYW5nZSBldmVudHMsIGFzIHdlIHdhbnQgdG8gcHJldmVudCB0eXBpbmcgdGhlcmVcbiAgICAgICAgICovXG4gICAgICAgIGlmIChfdmFsdWVJc051bWVyaWNTdHJpbmcgJiYgdHlwZW9mIGRlY2ltYWxTY2FsZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiByb3VuZFRvUHJlY2lzaW9uKHZhbHVlLCBkZWNpbWFsU2NhbGUsIEJvb2xlYW4oZml4ZWREZWNpbWFsU2NhbGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICB2YXIgcmVmJDEgPSB1c2VJbnRlcm5hbFZhbHVlcyhyb3VuZEluY29taW5nVmFsdWVUb1ByZWNpc2lvbih2YWx1ZSksIHJvdW5kSW5jb21pbmdWYWx1ZVRvUHJlY2lzaW9uKGRlZmF1bHRWYWx1ZSksIEJvb2xlYW4oX3ZhbHVlSXNOdW1lcmljU3RyaW5nKSwgX2Zvcm1hdCwgX3JlbW92ZUZvcm1hdHRpbmcsIG9uVmFsdWVDaGFuZ2UpO1xuICAgIHZhciByZWYkMV8wID0gcmVmJDFbMF07XG4gICAgdmFyIG51bUFzU3RyaW5nID0gcmVmJDFfMC5udW1Bc1N0cmluZztcbiAgICB2YXIgZm9ybWF0dGVkVmFsdWUgPSByZWYkMV8wLmZvcm1hdHRlZFZhbHVlO1xuICAgIHZhciBfb25WYWx1ZUNoYW5nZSA9IHJlZiQxWzFdO1xuICAgIHZhciBfb25LZXlEb3duID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGVsID0gZS50YXJnZXQ7XG4gICAgICAgIHZhciBrZXkgPSBlLmtleTtcbiAgICAgICAgdmFyIHNlbGVjdGlvblN0YXJ0ID0gZWwuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgIHZhciBzZWxlY3Rpb25FbmQgPSBlbC5zZWxlY3Rpb25FbmQ7XG4gICAgICAgIHZhciB2YWx1ZSA9IGVsLnZhbHVlOyBpZiAoIHZhbHVlID09PSB2b2lkIDAgKSB2YWx1ZSA9ICcnO1xuICAgICAgICAvLyBpZiB1c2VyIHRyaWVzIHRvIGRlbGV0ZSBwYXJ0aWFsIHByZWZpeCB0aGVuIGlnbm9yZSBpdFxuICAgICAgICBpZiAoKGtleSA9PT0gJ0JhY2tzcGFjZScgfHwga2V5ID09PSAnRGVsZXRlJykgJiYgc2VsZWN0aW9uRW5kIDwgcHJlZml4Lmxlbmd0aCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIG11bHRpcGxlIGNoYXJhY3RlcnMgYXJlIHNlbGVjdGVkIGFuZCB1c2VyIGhpdHMgYmFja3NwYWNlLCBubyBuZWVkIHRvIGhhbmRsZSBhbnl0aGluZyBtYW51YWxseVxuICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgIT09IHNlbGVjdGlvbkVuZCkge1xuICAgICAgICAgICAgb25LZXlEb3duKGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHVzZXIgaGl0cyBiYWNrc3BhY2UsIHdoaWxlIHRoZSBjdXJzb3IgaXMgYmVmb3JlIHByZWZpeCwgYW5kIHRoZSBpbnB1dCBoYXMgbmVnYXRpb24sIHJlbW92ZSB0aGUgbmVnYXRpb25cbiAgICAgICAgaWYgKGtleSA9PT0gJ0JhY2tzcGFjZScgJiZcbiAgICAgICAgICAgIHZhbHVlWzBdID09PSAnLScgJiZcbiAgICAgICAgICAgIHNlbGVjdGlvblN0YXJ0ID09PSBwcmVmaXgubGVuZ3RoICsgMSAmJlxuICAgICAgICAgICAgYWxsb3dOZWdhdGl2ZSkge1xuICAgICAgICAgICAgLy8gYnJpbmcgdGhlIGN1cnNvciB0byBhZnRlciBuZWdhdGlvblxuICAgICAgICAgICAgc2V0Q2FyZXRQb3NpdGlvbihlbCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG9uJ3QgYWxsb3cgdXNlciB0byBkZWxldGUgZGVjaW1hbCBzZXBhcmF0b3Igd2hlbiBkZWNpbWFsU2NhbGUgYW5kIGZpeGVkRGVjaW1hbFNjYWxlIGlzIHNldFxuICAgICAgICBpZiAoZGVjaW1hbFNjYWxlICYmIGZpeGVkRGVjaW1hbFNjYWxlKSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnQmFja3NwYWNlJyAmJiB2YWx1ZVtzZWxlY3Rpb25TdGFydCAtIDFdID09PSBkZWNpbWFsU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgc2V0Q2FyZXRQb3NpdGlvbihlbCwgc2VsZWN0aW9uU3RhcnQgLSAxKTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdEZWxldGUnICYmIHZhbHVlW3NlbGVjdGlvblN0YXJ0XSA9PT0gZGVjaW1hbFNlcGFyYXRvcikge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB1c2VyIHByZXNzZXMgdGhlIGFsbG93ZWQgZGVjaW1hbCBzZXBhcmF0b3IgYmVmb3JlIHRoZSBzZXBhcmF0b3IsIG1vdmUgdGhlIGN1cnNvciBhZnRlciB0aGUgc2VwYXJhdG9yXG4gICAgICAgIGlmICgoYWxsb3dlZERlY2ltYWxTZXBhcmF0b3JzID09PSBudWxsIHx8IGFsbG93ZWREZWNpbWFsU2VwYXJhdG9ycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWxsb3dlZERlY2ltYWxTZXBhcmF0b3JzLmluY2x1ZGVzKGtleSkpICYmIHZhbHVlW3NlbGVjdGlvblN0YXJ0XSA9PT0gZGVjaW1hbFNlcGFyYXRvcikge1xuICAgICAgICAgICAgc2V0Q2FyZXRQb3NpdGlvbihlbCwgc2VsZWN0aW9uU3RhcnQgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX3Rob3VzYW5kU2VwYXJhdG9yID0gdGhvdXNhbmRTZXBhcmF0b3IgPT09IHRydWUgPyAnLCcgOiB0aG91c2FuZFNlcGFyYXRvcjtcbiAgICAgICAgLy8gbW92ZSBjdXJzb3Igd2hlbiBkZWxldGUgb3IgYmFja3NwYWNlIGlzIHByZXNzZWQgYmVmb3JlL2FmdGVyIHRob3VzYW5kIHNlcGFyYXRvclxuICAgICAgICBpZiAoa2V5ID09PSAnQmFja3NwYWNlJyAmJiB2YWx1ZVtzZWxlY3Rpb25TdGFydCAtIDFdID09PSBfdGhvdXNhbmRTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIHNldENhcmV0UG9zaXRpb24oZWwsIHNlbGVjdGlvblN0YXJ0IC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleSA9PT0gJ0RlbGV0ZScgJiYgdmFsdWVbc2VsZWN0aW9uU3RhcnRdID09PSBfdGhvdXNhbmRTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIHNldENhcmV0UG9zaXRpb24oZWwsIHNlbGVjdGlvblN0YXJ0ICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgb25LZXlEb3duKGUpO1xuICAgIH07XG4gICAgdmFyIF9vbkJsdXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgX3ZhbHVlID0gbnVtQXNTdHJpbmc7XG4gICAgICAgIC8vIGlmIHRoZXJlIG5vIG5vIG51bWVyaWMgdmFsdWUsIGNsZWFyIHRoZSBpbnB1dFxuICAgICAgICBpZiAoIV92YWx1ZS5tYXRjaCgvXFxkL2cpKSB7XG4gICAgICAgICAgICBfdmFsdWUgPSAnJztcbiAgICAgICAgfVxuICAgICAgICAvLyBjbGVhciBsZWFkaW5nIDBzXG4gICAgICAgIGlmICghYWxsb3dMZWFkaW5nWmVyb3MpIHtcbiAgICAgICAgICAgIF92YWx1ZSA9IGZpeExlYWRpbmdaZXJvKF92YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXBwbHkgZml4ZWREZWNpbWFsU2NhbGUgb24gYmx1ciBldmVudFxuICAgICAgICBpZiAoZml4ZWREZWNpbWFsU2NhbGUgJiYgZGVjaW1hbFNjYWxlKSB7XG4gICAgICAgICAgICBfdmFsdWUgPSByb3VuZFRvUHJlY2lzaW9uKF92YWx1ZSwgZGVjaW1hbFNjYWxlLCBmaXhlZERlY2ltYWxTY2FsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF92YWx1ZSAhPT0gbnVtQXNTdHJpbmcpIHtcbiAgICAgICAgICAgIHZhciBmb3JtYXR0ZWRWYWx1ZSA9IGZvcm1hdChfdmFsdWUsIHByb3BzKTtcbiAgICAgICAgICAgIF9vblZhbHVlQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZTogZm9ybWF0dGVkVmFsdWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IF92YWx1ZSxcbiAgICAgICAgICAgICAgICBmbG9hdFZhbHVlOiBwYXJzZUZsb2F0KF92YWx1ZSksXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgZXZlbnQ6IGUsXG4gICAgICAgICAgICAgICAgc291cmNlOiBTb3VyY2VUeXBlLmV2ZW50LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgb25CbHVyKGUpO1xuICAgIH07XG4gICAgdmFyIGlzVmFsaWRJbnB1dENoYXJhY3RlciA9IGZ1bmN0aW9uIChpbnB1dENoYXIpIHtcbiAgICAgICAgaWYgKGlucHV0Q2hhciA9PT0gZGVjaW1hbFNlcGFyYXRvcilcbiAgICAgICAgICAgIHsgcmV0dXJuIHRydWU7IH1cbiAgICAgICAgcmV0dXJuIGNoYXJJc051bWJlcihpbnB1dENoYXIpO1xuICAgIH07XG4gICAgdmFyIGlzQ2hhcmFjdGVyU2FtZSA9IGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRWYWx1ZSA9IHJlZi5jdXJyZW50VmFsdWU7XG4gICAgICAgIHZhciBsYXN0VmFsdWUgPSByZWYubGFzdFZhbHVlO1xuICAgICAgICB2YXIgZm9ybWF0dGVkVmFsdWUgPSByZWYuZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgIHZhciBjdXJyZW50VmFsdWVJbmRleCA9IHJlZi5jdXJyZW50VmFsdWVJbmRleDtcbiAgICAgICAgdmFyIGZvcm1hdHRlZFZhbHVlSW5kZXggPSByZWYuZm9ybWF0dGVkVmFsdWVJbmRleDtcblxuICAgICAgICB2YXIgY3VyQ2hhciA9IGN1cnJlbnRWYWx1ZVtjdXJyZW50VmFsdWVJbmRleF07XG4gICAgICAgIHZhciBuZXdDaGFyID0gZm9ybWF0dGVkVmFsdWVbZm9ybWF0dGVkVmFsdWVJbmRleF07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOT1RFOiBhcyB0aG91c2FuZCBzZXBhcmF0b3IgYW5kIGFsbG93ZWREZWNpbWFsU2VwYXJhdG9ycyBjYW4gYmUgc2FtZSwgd2UgbmVlZCB0byBjaGVjayBvblxuICAgICAgICAgKiB0eXBlZCByYW5nZSBpZiB3ZSBoYXZlIHR5cGVkIGFueSBjaGFyYWN0ZXIgZnJvbSBhbGxvd2VkRGVjaW1hbFNlcGFyYXRvcnMsIGluIHRoYXQgY2FzZSB3ZVxuICAgICAgICAgKiBjb25zaWRlciBkaWZmZXJlbnQgY2hhcmFjdGVycyBsaWtlICwgYW5kIC4gc2FtZSB3aXRoaW4gdGhlIHJhbmdlIG9mIHVwZGF0ZWQgdmFsdWUuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgdHlwZWRSYW5nZSA9IGZpbmRDaGFuZ2VSYW5nZShsYXN0VmFsdWUsIGN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIHZhciB0byA9IHR5cGVkUmFuZ2UudG87XG4gICAgICAgIGlmIChjdXJyZW50VmFsdWVJbmRleCA+PSB0by5zdGFydCAmJlxuICAgICAgICAgICAgY3VycmVudFZhbHVlSW5kZXggPCB0by5lbmQgJiZcbiAgICAgICAgICAgIGFsbG93ZWREZWNpbWFsU2VwYXJhdG9ycyAmJlxuICAgICAgICAgICAgYWxsb3dlZERlY2ltYWxTZXBhcmF0b3JzLmluY2x1ZGVzKGN1ckNoYXIpICYmXG4gICAgICAgICAgICBuZXdDaGFyID09PSBkZWNpbWFsU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VyQ2hhciA9PT0gbmV3Q2hhcjtcbiAgICB9O1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3RQcm9wcyksIHsgdmFsdWU6IGZvcm1hdHRlZFZhbHVlLCB2YWx1ZUlzTnVtZXJpY1N0cmluZzogZmFsc2UsIGlzVmFsaWRJbnB1dENoYXJhY3RlcjogaXNWYWxpZElucHV0Q2hhcmFjdGVyLFxuICAgICAgICBpc0NoYXJhY3RlclNhbWU6IGlzQ2hhcmFjdGVyU2FtZSwgb25WYWx1ZUNoYW5nZTogX29uVmFsdWVDaGFuZ2UsIGZvcm1hdDogX2Zvcm1hdCwgcmVtb3ZlRm9ybWF0dGluZzogX3JlbW92ZUZvcm1hdHRpbmcsIGdldENhcmV0Qm91bmRhcnk6IGZ1bmN0aW9uIChmb3JtYXR0ZWRWYWx1ZSkgeyByZXR1cm4gZ2V0Q2FyZXRCb3VuZGFyeShmb3JtYXR0ZWRWYWx1ZSwgcHJvcHMpOyB9LCBvbktleURvd246IF9vbktleURvd24sIG9uQmx1cjogX29uQmx1ciB9KTtcbn1cbmZ1bmN0aW9uIE51bWVyaWNGb3JtYXQocHJvcHMpIHtcbiAgICB2YXIgbnVtZXJpY0Zvcm1hdFByb3BzID0gdXNlTnVtZXJpY0Zvcm1hdChwcm9wcyk7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTnVtYmVyRm9ybWF0QmFzZSwgT2JqZWN0LmFzc2lnbih7fSwgbnVtZXJpY0Zvcm1hdFByb3BzKSk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdCQxKG51bVN0ciwgcHJvcHMpIHtcbiAgICB2YXIgZm9ybWF0ID0gcHJvcHMuZm9ybWF0O1xuICAgIHZhciBhbGxvd0VtcHR5Rm9ybWF0dGluZyA9IHByb3BzLmFsbG93RW1wdHlGb3JtYXR0aW5nO1xuICAgIHZhciBtYXNrID0gcHJvcHMubWFzaztcbiAgICB2YXIgcGF0dGVybkNoYXIgPSBwcm9wcy5wYXR0ZXJuQ2hhcjsgaWYgKCBwYXR0ZXJuQ2hhciA9PT0gdm9pZCAwICkgcGF0dGVybkNoYXIgPSAnIyc7XG4gICAgaWYgKG51bVN0ciA9PT0gJycgJiYgIWFsbG93RW1wdHlGb3JtYXR0aW5nKVxuICAgICAgICB7IHJldHVybiAnJzsgfVxuICAgIHZhciBoYXNoQ291bnQgPSAwO1xuICAgIHZhciBmb3JtYXR0ZWROdW1iZXJBcnkgPSBmb3JtYXQuc3BsaXQoJycpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsbiA9IGZvcm1hdC5sZW5ndGg7IGkgPCBsbjsgaSsrKSB7XG4gICAgICAgIGlmIChmb3JtYXRbaV0gPT09IHBhdHRlcm5DaGFyKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWROdW1iZXJBcnlbaV0gPSBudW1TdHJbaGFzaENvdW50XSB8fCBnZXRNYXNrQXRJbmRleChtYXNrLCBoYXNoQ291bnQpO1xuICAgICAgICAgICAgaGFzaENvdW50ICs9IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvcm1hdHRlZE51bWJlckFyeS5qb2luKCcnKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUZvcm1hdHRpbmckMSh2YWx1ZSwgY2hhbmdlTWV0YSwgcHJvcHMpIHtcbiAgICBpZiAoIGNoYW5nZU1ldGEgPT09IHZvaWQgMCApIGNoYW5nZU1ldGEgPSBnZXREZWZhdWx0Q2hhbmdlTWV0YSh2YWx1ZSk7XG5cbiAgICB2YXIgZm9ybWF0ID0gcHJvcHMuZm9ybWF0O1xuICAgIHZhciBwYXR0ZXJuQ2hhciA9IHByb3BzLnBhdHRlcm5DaGFyOyBpZiAoIHBhdHRlcm5DaGFyID09PSB2b2lkIDAgKSBwYXR0ZXJuQ2hhciA9ICcjJztcbiAgICB2YXIgZnJvbSA9IGNoYW5nZU1ldGEuZnJvbTtcbiAgICB2YXIgdG8gPSBjaGFuZ2VNZXRhLnRvO1xuICAgIHZhciBsYXN0VmFsdWUgPSBjaGFuZ2VNZXRhLmxhc3RWYWx1ZTsgaWYgKCBsYXN0VmFsdWUgPT09IHZvaWQgMCApIGxhc3RWYWx1ZSA9ICcnO1xuICAgIHZhciBpc051bWVyaWNTbG90ID0gZnVuY3Rpb24gKGNhcmV0UG9zKSB7IHJldHVybiBmb3JtYXRbY2FyZXRQb3NdID09PSBwYXR0ZXJuQ2hhcjsgfTtcbiAgICB2YXIgcmVtb3ZlRm9ybWF0Q2hhciA9IGZ1bmN0aW9uIChzdHJpbmcsIHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgdmFyIHN0ciA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGlzTnVtZXJpY1Nsb3Qoc3RhcnRJbmRleCArIGkpICYmIGNoYXJJc051bWJlcihzdHJpbmdbaV0pKSB7XG4gICAgICAgICAgICAgICAgc3RyICs9IHN0cmluZ1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH07XG4gICAgdmFyIGV4dHJhY3ROdW1iZXJzID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyLnJlcGxhY2UoL1teMC05XS9nLCAnJyk7IH07XG4gICAgLy8gaWYgZm9ybWF0IGRvZXNuJ3QgaGF2ZSBhbnkgbnVtYmVyLCByZW1vdmUgYWxsIHRoZSBub24gbnVtZXJpYyBjaGFyYWN0ZXJzXG4gICAgaWYgKCFmb3JtYXQubWF0Y2goL1xcZC8pKSB7XG4gICAgICAgIHJldHVybiBleHRyYWN0TnVtYmVycyh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGlmIHVzZXIgcGFzdGUgdGhlIHdob2xlIGZvcm1hdHRlZCB0ZXh0IGluIGFuIGVtcHR5IGlucHV0IG9yIGRvaW5nIHNlbGVjdCBhbGwgYW5kIHBhc3RlLCBjaGVjayBpZiBtYXRjaGVzIHRvIHRoZSBwYXR0ZXJuXG4gICAgICogYW5kIHJlbW92ZSB0aGUgZm9ybWF0IGNoYXJhY3RlcnMsIGlmIHRoZXJlIGlzIGEgbWlzbWF0Y2ggb24gdGhlIHBhdHRlcm4sIGRvIHBsYW5lIG51bWJlciBleHRyYWN0XG4gICAgICovXG4gICAgaWYgKChsYXN0VmFsdWUgPT09ICcnIHx8IGZyb20uZW5kIC0gZnJvbS5zdGFydCA9PT0gbGFzdFZhbHVlLmxlbmd0aCkgJiZcbiAgICAgICAgdmFsdWUubGVuZ3RoID09PSBmb3JtYXQubGVuZ3RoKSB7XG4gICAgICAgIHZhciBzdHIgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGlzTnVtZXJpY1Nsb3QoaSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhcklzTnVtYmVyKHZhbHVlW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBzdHIgKz0gdmFsdWVbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWVbaV0gIT09IGZvcm1hdFtpXSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgbWlzbWF0Y2ggb24gdGhlIHBhdHRlcm4sIGRvIHBsYW5lIG51bWJlciBleHRyYWN0XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4dHJhY3ROdW1iZXJzKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3IgcGFydGlhbCBjaGFuZ2UsXG4gICAgICogd2hlcmUgZXZlciB0aGVyZSBpcyBhIGNoYW5nZSBvbiB0aGUgaW5wdXQsIHdlIGNhbiBicmVhayB0aGUgbnVtYmVyIGluIHRocmVlIHBhcnRzXG4gICAgICogMXN0OiBsZWZ0IHBhcnQgd2hpY2ggaXMgdW5jaGFuZ2VkXG4gICAgICogMm5kOiBtaWRkbGUgcGFydCB3aGljaCBpcyBjaGFuZ2VkXG4gICAgICogM3JkOiByaWdodCBwYXJ0IHdoaWNoIGlzIHVuY2hhbmdlZFxuICAgICAqXG4gICAgICogVGhlIGZpcnN0IGFuZCB0aGlyZCBzZWN0aW9uIHdpbGwgYmUgc2FtZSBhcyBsYXN0IHZhbHVlLCBvbmx5IHRoZSBtaWRkbGUgcGFydCB3aWxsIGNoYW5nZVxuICAgICAqIFdlIGNhbiBjb25zaWRlciBvbiB0aGUgY2hhbmdlIHBhcnQgYWxsIHRoZSBuZXcgY2hhcmFjdGVycyBhcmUgbm9uIGZvcm1hdCBjaGFyYWN0ZXJzLlxuICAgICAqIEFuZCBvbiB0aGUgZmlyc3QgYW5kIGxhc3Qgc2VjdGlvbiBpdCBjYW4gaGF2ZSBwYXJ0aWFsIGZvcm1hdCBjaGFyYWN0ZXJzLlxuICAgICAqXG4gICAgICogV2UgcGljayBmaXJzdCBhbmQgbGFzdCBzZWN0aW9uIGZyb20gdGhlIGxhc3RWYWx1ZSAoYXMgdGhhdCBoYXMgMS0xIG1hcHBpbmcgd2l0aCBmb3JtYXQpXG4gICAgICogYW5kIG1pZGRsZSBvbmUgZnJvbSB0aGUgdXBkYXRlIHZhbHVlLlxuICAgICAqL1xuICAgIHZhciBmaXJzdFNlY3Rpb24gPSBsYXN0VmFsdWUuc3Vic3RyaW5nKDAsIGZyb20uc3RhcnQpO1xuICAgIHZhciBtaWRkbGVTZWN0aW9uID0gdmFsdWUuc3Vic3RyaW5nKHRvLnN0YXJ0LCB0by5lbmQpO1xuICAgIHZhciBsYXN0U2VjdGlvbiA9IGxhc3RWYWx1ZS5zdWJzdHJpbmcoZnJvbS5lbmQpO1xuICAgIHJldHVybiAoXCJcIiArIChyZW1vdmVGb3JtYXRDaGFyKGZpcnN0U2VjdGlvbiwgMCkpICsgKGV4dHJhY3ROdW1iZXJzKG1pZGRsZVNlY3Rpb24pKSArIChyZW1vdmVGb3JtYXRDaGFyKGxhc3RTZWN0aW9uLCBmcm9tLmVuZCkpKTtcbn1cbmZ1bmN0aW9uIGdldENhcmV0Qm91bmRhcnkkMShmb3JtYXR0ZWRWYWx1ZSwgcHJvcHMpIHtcbiAgICB2YXIgZm9ybWF0ID0gcHJvcHMuZm9ybWF0O1xuICAgIHZhciBtYXNrID0gcHJvcHMubWFzaztcbiAgICB2YXIgcGF0dGVybkNoYXIgPSBwcm9wcy5wYXR0ZXJuQ2hhcjsgaWYgKCBwYXR0ZXJuQ2hhciA9PT0gdm9pZCAwICkgcGF0dGVybkNoYXIgPSAnIyc7XG4gICAgdmFyIGJvdW5kYXJ5QXJ5ID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogZm9ybWF0dGVkVmFsdWUubGVuZ3RoICsgMSB9KS5tYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSk7XG4gICAgdmFyIGhhc2hDb3VudCA9IDA7XG4gICAgdmFyIGZpcnN0RW1wdHlTbG90ID0gLTE7XG4gICAgdmFyIG1hc2tBbmRJbmRleE1hcCA9IHt9O1xuICAgIGZvcm1hdC5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoY2hhciwgaW5kZXgpIHtcbiAgICAgICAgdmFyIG1hc2tBdEluZGV4ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoY2hhciA9PT0gcGF0dGVybkNoYXIpIHtcbiAgICAgICAgICAgIGhhc2hDb3VudCsrO1xuICAgICAgICAgICAgbWFza0F0SW5kZXggPSBnZXRNYXNrQXRJbmRleChtYXNrLCBoYXNoQ291bnQgLSAxKTtcbiAgICAgICAgICAgIGlmIChmaXJzdEVtcHR5U2xvdCA9PT0gLTEgJiYgZm9ybWF0dGVkVmFsdWVbaW5kZXhdID09PSBtYXNrQXRJbmRleCkge1xuICAgICAgICAgICAgICAgIGZpcnN0RW1wdHlTbG90ID0gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWFza0FuZEluZGV4TWFwW2luZGV4XSA9IG1hc2tBdEluZGV4O1xuICAgIH0pO1xuICAgIHZhciBpc1Bvc0FsbG93ZWQgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIC8vIHRoZSBwb3NpdGlvbiBpcyBhbGxvd2VkIGlmIHRoZSBwb3NpdGlvbiBpcyBub3QgbWFza2VkIGFuZCB2YWxpZCBudW1iZXIgYXJlYVxuICAgICAgICByZXR1cm4gZm9ybWF0W3Bvc10gPT09IHBhdHRlcm5DaGFyICYmIGZvcm1hdHRlZFZhbHVlW3Bvc10gIT09IG1hc2tBbmRJbmRleE1hcFtwb3NdO1xuICAgIH07XG4gICAgZm9yICh2YXIgaSA9IDAsIGxuID0gYm91bmRhcnlBcnkubGVuZ3RoOyBpIDwgbG47IGkrKykge1xuICAgICAgICAvLyBjb25zaWRlciBjYXJldCB0byBiZSBpbiBib3VuZGFyeSBpZiBpdCBpcyBiZWZvcmUgb3IgYWZ0ZXIgbnVtZXJpYyB2YWx1ZVxuICAgICAgICAvLyBOb3RlOiBvbiBwYXR0ZXJuIGJhc2VkIGZvcm1hdCBpdHMgZGVub3RlZCBieSBwYXR0ZXJuQ2hhcmFjdGVyXG4gICAgICAgIC8vIHdlIHNob3VsZCBhbHNvIGFsbG93IHVzZXIgdG8gcHV0IGN1cnNvciBvbiBmaXJzdCBlbXB0eSBzbG90XG4gICAgICAgIGJvdW5kYXJ5QXJ5W2ldID0gaSA9PT0gZmlyc3RFbXB0eVNsb3QgfHwgaXNQb3NBbGxvd2VkKGkpIHx8IGlzUG9zQWxsb3dlZChpIC0gMSk7XG4gICAgfVxuICAgIC8vIHRoZSBmaXJzdCBwYXR0ZXJuQ2hhciBwb3NpdGlvbiBpcyBhbHdheXMgYWxsb3dlZFxuICAgIGJvdW5kYXJ5QXJ5W2Zvcm1hdC5pbmRleE9mKHBhdHRlcm5DaGFyKV0gPSB0cnVlO1xuICAgIHJldHVybiBib3VuZGFyeUFyeTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcHMocHJvcHMpIHtcbiAgICB2YXIgbWFzayA9IHByb3BzLm1hc2s7XG4gICAgaWYgKG1hc2spIHtcbiAgICAgICAgdmFyIG1hc2tBc1N0ciA9IG1hc2sgPT09ICdzdHJpbmcnID8gbWFzayA6IG1hc2sudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKG1hc2tBc1N0ci5tYXRjaCgvXFxkL2cpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKFwiTWFzayBcIiArIG1hc2sgKyBcIiBzaG91bGQgbm90IGNvbnRhaW4gbnVtZXJpYyBjaGFyYWN0ZXI7XCIpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGlzTnVtZXJpY1N0cmluZyQxKHZhbCwgZm9ybWF0KSB7XG4gICAgLy93ZSBjYW4gdHJlYXQgZW1wdHkgc3RyaW5nIGFzIG51bWVyaWMgc3RyaW5nXG4gICAgaWYgKHZhbCA9PT0gJycpXG4gICAgICAgIHsgcmV0dXJuIHRydWU7IH1cbiAgICByZXR1cm4gIShmb3JtYXQgPT09IG51bGwgfHwgZm9ybWF0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmb3JtYXQubWF0Y2goL1xcZC8pKSAmJiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyAmJiAoISF2YWwubWF0Y2goL15cXGQrJC8pIHx8IHZhbCA9PT0gJycpO1xufVxuZnVuY3Rpb24gdXNlUGF0dGVybkZvcm1hdChwcm9wcykge1xuICAgIHZhciBtYXNrID0gcHJvcHMubWFzaztcbiAgICB2YXIgYWxsb3dFbXB0eUZvcm1hdHRpbmcgPSBwcm9wcy5hbGxvd0VtcHR5Rm9ybWF0dGluZztcbiAgICB2YXIgZm9ybWF0UHJvcCA9IHByb3BzLmZvcm1hdDtcbiAgICB2YXIgaW5wdXRNb2RlID0gcHJvcHMuaW5wdXRNb2RlOyBpZiAoIGlucHV0TW9kZSA9PT0gdm9pZCAwICkgaW5wdXRNb2RlID0gJ251bWVyaWMnO1xuICAgIHZhciBvbktleURvd24gPSBwcm9wcy5vbktleURvd247IGlmICggb25LZXlEb3duID09PSB2b2lkIDAgKSBvbktleURvd24gPSBub29wO1xuICAgIHZhciBwYXR0ZXJuQ2hhciA9IHByb3BzLnBhdHRlcm5DaGFyOyBpZiAoIHBhdHRlcm5DaGFyID09PSB2b2lkIDAgKSBwYXR0ZXJuQ2hhciA9ICcjJztcbiAgICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgIHZhciB2YWx1ZUlzTnVtZXJpY1N0cmluZyA9IHByb3BzLnZhbHVlSXNOdW1lcmljU3RyaW5nO1xuICAgIHZhciByZXN0UHJvcHMgPSBfX3Jlc3QocHJvcHMsIFtcIm1hc2tcIiwgXCJhbGxvd0VtcHR5Rm9ybWF0dGluZ1wiLCBcImZvcm1hdFwiLCBcImlucHV0TW9kZVwiLCBcIm9uS2V5RG93blwiLCBcInBhdHRlcm5DaGFyXCIsIFwidmFsdWVcIiwgXCJkZWZhdWx0VmFsdWVcIiwgXCJ2YWx1ZUlzTnVtZXJpY1N0cmluZ1wiXSk7XG4gICAgLy8gdmFsaWRhdGUgcHJvcHNcbiAgICB2YWxpZGF0ZVByb3BzKHByb3BzKTtcbiAgICB2YXIgX2dldENhcmV0Qm91bmRhcnkgPSBmdW5jdGlvbiAoZm9ybWF0dGVkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGdldENhcmV0Qm91bmRhcnkkMShmb3JtYXR0ZWRWYWx1ZSwgcHJvcHMpO1xuICAgIH07XG4gICAgdmFyIF9vbktleURvd24gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIga2V5ID0gZS5rZXk7XG4gICAgICAgIHZhciBlbCA9IGUudGFyZ2V0O1xuICAgICAgICB2YXIgc2VsZWN0aW9uU3RhcnQgPSBlbC5zZWxlY3Rpb25TdGFydDtcbiAgICAgICAgdmFyIHNlbGVjdGlvbkVuZCA9IGVsLnNlbGVjdGlvbkVuZDtcbiAgICAgICAgdmFyIHZhbHVlID0gZWwudmFsdWU7XG4gICAgICAgIC8vIGlmIG11bHRpcGxlIGNoYXJhY3RlcnMgYXJlIHNlbGVjdGVkIGFuZCB1c2VyIGhpdHMgYmFja3NwYWNlLCBubyBuZWVkIHRvIGhhbmRsZSBhbnl0aGluZyBtYW51YWxseVxuICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgIT09IHNlbGVjdGlvbkVuZCkge1xuICAgICAgICAgICAgb25LZXlEb3duKGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJyaW5nIHRoZSBjdXJzb3IgdG8gY2xvc2VzdCBudW1lcmljIHNlY3Rpb25cbiAgICAgICAgdmFyIGNhcmV0UG9zID0gc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgIC8vIGlmIGJhY2tzcGFjZSBpcyBwcmVzc2VkIGFmdGVyIHRoZSBmb3JtYXQgY2hhcmFjdGVycywgYnJpbmcgaXQgdG8gbnVtZXJpYyBzZWN0aW9uXG4gICAgICAgIC8vIGlmIGRlbGV0ZSBpcyBwcmVzc2VkIGJlZm9yZSB0aGUgZm9ybWF0IGNoYXJhY3RlcnMsIGJyaW5nIGl0IHRvIG51bWVyaWMgc2VjdGlvblxuICAgICAgICBpZiAoa2V5ID09PSAnQmFja3NwYWNlJyB8fCBrZXkgPT09ICdEZWxldGUnKSB7XG4gICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdCYWNrc3BhY2UnKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGNhcmV0UG9zID4gMCAmJiBmb3JtYXRQcm9wW2NhcmV0UG9zIC0gMV0gIT09IHBhdHRlcm5DaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9ICdsZWZ0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBmb3JtYXRMbiA9IGZvcm1hdFByb3AubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjYXJldFBvcyA8IGZvcm1hdExuICYmIGZvcm1hdFByb3BbY2FyZXRQb3NdICE9PSBwYXR0ZXJuQ2hhcikge1xuICAgICAgICAgICAgICAgICAgICBjYXJldFBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSAncmlnaHQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FyZXRQb3MgPSBnZXRDYXJldFBvc0luQm91bmRhcnkodmFsdWUsIGNhcmV0UG9zLCBfZ2V0Q2FyZXRCb3VuZGFyeSh2YWx1ZSksIGRpcmVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZm9ybWF0UHJvcFtjYXJldFBvc10gIT09IHBhdHRlcm5DaGFyICYmXG4gICAgICAgICAgICBrZXkgIT09ICdBcnJvd0xlZnQnICYmXG4gICAgICAgICAgICBrZXkgIT09ICdBcnJvd1JpZ2h0Jykge1xuICAgICAgICAgICAgLy8gaWYgdXNlciBpcyB0eXBpbmcgb24gZm9ybWF0IGNoYXJhY3RlciBwb3NpdGlvbiwgYnJpbmcgdXNlciB0byBuZXh0IGFsbG93ZWQgY2FyZXQgcG9zaXRpb25cbiAgICAgICAgICAgIGNhcmV0UG9zID0gZ2V0Q2FyZXRQb3NJbkJvdW5kYXJ5KHZhbHVlLCBjYXJldFBvcyArIDEsIF9nZXRDYXJldEJvdW5kYXJ5KHZhbHVlKSwgJ3JpZ2h0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UgY2hhbmdpbmcgY2FyZXQgcG9zaXRpb24sIHNldCB0aGUgY2FyZXQgcG9zaXRpb25cbiAgICAgICAgaWYgKGNhcmV0UG9zICE9PSBzZWxlY3Rpb25TdGFydCkge1xuICAgICAgICAgICAgc2V0Q2FyZXRQb3NpdGlvbihlbCwgY2FyZXRQb3MpO1xuICAgICAgICB9XG4gICAgICAgIG9uS2V5RG93bihlKTtcbiAgICB9O1xuICAgIC8vIHRyeSB0byBmaWd1cmUgb3V0IGlzVmFsdWVOdW1lcmljU3RyaW5nIGJhc2VkIG9uIGZvcm1hdCBwcm9wIGFuZCB2YWx1ZVxuICAgIHZhciBfdmFsdWUgPSBpc05pbCh2YWx1ZSkgPyBkZWZhdWx0VmFsdWUgOiB2YWx1ZTtcbiAgICB2YXIgaXNWYWx1ZU51bWVyaWNTdHJpbmcgPSB2YWx1ZUlzTnVtZXJpY1N0cmluZyAhPT0gbnVsbCAmJiB2YWx1ZUlzTnVtZXJpY1N0cmluZyAhPT0gdm9pZCAwID8gdmFsdWVJc051bWVyaWNTdHJpbmcgOiBpc051bWVyaWNTdHJpbmckMShfdmFsdWUsIGZvcm1hdFByb3ApO1xuICAgIHZhciBfcHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSwgeyB2YWx1ZUlzTnVtZXJpY1N0cmluZzogaXNWYWx1ZU51bWVyaWNTdHJpbmcgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzdFByb3BzKSwgeyB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogZGVmYXVsdFZhbHVlLCB2YWx1ZUlzTnVtZXJpY1N0cmluZzogaXNWYWx1ZU51bWVyaWNTdHJpbmcsIGlucHV0TW9kZTogaW5wdXRNb2RlLCBmb3JtYXQ6IGZ1bmN0aW9uIChudW1TdHIpIHsgcmV0dXJuIGZvcm1hdCQxKG51bVN0ciwgX3Byb3BzKTsgfSwgcmVtb3ZlRm9ybWF0dGluZzogZnVuY3Rpb24gKGlucHV0VmFsdWUsIGNoYW5nZU1ldGEpIHsgcmV0dXJuIHJlbW92ZUZvcm1hdHRpbmckMShpbnB1dFZhbHVlLCBjaGFuZ2VNZXRhLCBfcHJvcHMpOyB9LCBnZXRDYXJldEJvdW5kYXJ5OiBfZ2V0Q2FyZXRCb3VuZGFyeSwgb25LZXlEb3duOiBfb25LZXlEb3duIH0pO1xufVxuZnVuY3Rpb24gUGF0dGVybkZvcm1hdChwcm9wcykge1xuICAgIHZhciBwYXR0ZXJuRm9ybWF0UHJvcHMgPSB1c2VQYXR0ZXJuRm9ybWF0KHByb3BzKTtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChOdW1iZXJGb3JtYXRCYXNlLCBPYmplY3QuYXNzaWduKHt9LCBwYXR0ZXJuRm9ybWF0UHJvcHMpKTtcbn1cblxuZXhwb3J0IHsgTnVtYmVyRm9ybWF0QmFzZSwgTnVtZXJpY0Zvcm1hdCwgUGF0dGVybkZvcm1hdCwgZ2V0Q2FyZXRCb3VuZGFyeSBhcyBnZXROdW1lcmljQ2FyZXRCb3VuZGFyeSwgZ2V0Q2FyZXRCb3VuZGFyeSQxIGFzIGdldFBhdHRlcm5DYXJldEJvdW5kYXJ5LCBmb3JtYXQgYXMgbnVtZXJpY0Zvcm1hdHRlciwgZm9ybWF0JDEgYXMgcGF0dGVybkZvcm1hdHRlciwgcmVtb3ZlRm9ybWF0dGluZyBhcyByZW1vdmVOdW1lcmljRm9ybWF0LCByZW1vdmVGb3JtYXR0aW5nJDEgYXMgcmVtb3ZlUGF0dGVybkZvcm1hdCwgdXNlTnVtZXJpY0Zvcm1hdCwgdXNlUGF0dGVybkZvcm1hdCB9O1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlU3RhdGUiLCJ1c2VNZW1vIiwidXNlUmVmIiwidXNlRWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0IiwiX19yZXN0IiwicyIsImUiLCJ0IiwicCIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImluZGV4T2YiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJpIiwibGVuZ3RoIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJTb3VyY2VUeXBlIiwibm9vcCIsIm1lbW9pemVPbmNlIiwiY2IiLCJsYXN0QXJncyIsImxhc3RWYWx1ZSIsInVuZGVmaW5lZCIsImFyZ3MiLCJsZW4iLCJhcmd1bWVudHMiLCJldmVyeSIsInZhbHVlIiwiaW5kZXgiLCJhcHBseSIsImNoYXJJc051bWJlciIsImNoYXIiLCJtYXRjaCIsImlzTmlsIiwidmFsIiwiaXNOYW5WYWx1ZSIsImlzTmFOIiwiaXNOb3RWYWxpZFZhbHVlIiwiaXNGaW5pdGUiLCJlc2NhcGVSZWdFeHAiLCJzdHIiLCJyZXBsYWNlIiwiZ2V0VGhvdXNhbmRzR3JvdXBSZWdleCIsInRob3VzYW5kc0dyb3VwU3R5bGUiLCJhcHBseVRob3VzYW5kU2VwYXJhdG9yIiwidGhvdXNhbmRTZXBhcmF0b3IiLCJ0aG91c2FuZHNHcm91cFJlZ2V4Iiwic2VhcmNoIiwic3Vic3RyaW5nIiwidXNlUGVyc2lzdGVudENhbGxiYWNrIiwiY2FsbGJhY2tSZWYiLCJjdXJyZW50IiwicGVyc2lzdGVudENiUmVmIiwic3BsaXREZWNpbWFsIiwibnVtU3RyIiwiYWxsb3dOZWdhdGl2ZSIsImhhc05lZ2F0aW9uIiwiYWRkTmVnYXRpb24iLCJwYXJ0cyIsInNwbGl0IiwiYmVmb3JlRGVjaW1hbCIsImFmdGVyRGVjaW1hbCIsImZpeExlYWRpbmdaZXJvIiwiaXNOZWdhdGl2ZSIsImxpbWl0VG9TY2FsZSIsInNjYWxlIiwiZml4ZWREZWNpbWFsU2NhbGUiLCJmaWxsZXIiLCJyZXBlYXQiLCJjb3VudCIsIkFycmF5Iiwiam9pbiIsInRvTnVtZXJpY1N0cmluZyIsIm51bSIsIl9udW0iLCJzaWduIiwicmVmIiwiY29lZmZpY2llbnQiLCJleHBvbmVudCIsIk51bWJlciIsImRlY2ltYWxJbmRleCIsImNvZmZpZWNpZW50TG4iLCJNYXRoIiwiYWJzIiwicm91bmRUb1ByZWNpc2lvbiIsInNob3VsZEhhdmVEZWNpbWFsU2VwYXJhdG9yIiwiZmxvYXRWYWx1ZSIsInBhcnNlRmxvYXQiLCJmbG9hdFZhbHVlU3RyIiwidG9GaXhlZCIsInJvdW5kZWREZWNpbWFsUGFydHMiLCJpbnRQYXJ0IiwicmV2ZXJzZSIsInJlZHVjZSIsInJvdW5kZWRTdHIiLCJpZHgiLCJ0b1N0cmluZyIsImRlY2ltYWxQYXJ0IiwibmVnYXRpb24iLCJkZWNpbWFsU2VwYXJhdG9yIiwic2V0Q2FyZXRQb3NpdGlvbiIsImVsIiwiY2FyZXRQb3MiLCJjcmVhdGVUZXh0UmFuZ2UiLCJyYW5nZSIsIm1vdmUiLCJzZWxlY3QiLCJzZWxlY3Rpb25TdGFydCIsImZvY3VzIiwic2V0U2VsZWN0aW9uUmFuZ2UiLCJmaW5kQ2hhbmdlUmFuZ2UiLCJwcmV2VmFsdWUiLCJuZXdWYWx1ZSIsImoiLCJwcmV2TGVuZ3RoIiwibmV3TGVuZ3RoIiwiZnJvbSIsInN0YXJ0IiwiZW5kIiwidG8iLCJmaW5kQ2hhbmdlZFJhbmdlRnJvbUNhcmV0UG9zaXRpb25zIiwibGFzdENhcmV0UG9zaXRpb25zIiwiY3VycmVudENhcmV0UG9zaXRpb24iLCJzdGFydFBvc2l0aW9uIiwibWluIiwic2VsZWN0aW9uRW5kIiwiY2xhbXAiLCJtYXgiLCJnZUlucHV0Q2FyZXRQb3NpdGlvbiIsImFkZElucHV0TW9kZSIsIm5hdmlnYXRvciIsInBsYXRmb3JtIiwidGVzdCIsImdldERlZmF1bHRDaGFuZ2VNZXRhIiwiZ2V0TWFza0F0SW5kZXgiLCJtYXNrIiwiZGVmYXVsdElzQ2hhcmFjdGVyU2FtZSIsImN1cnJlbnRWYWx1ZSIsImZvcm1hdHRlZFZhbHVlIiwiY3VycmVudFZhbHVlSW5kZXgiLCJmb3JtYXR0ZWRWYWx1ZUluZGV4IiwiZ2V0Q2FyZXRQb3NpdGlvbiIsIm5ld0Zvcm1hdHRlZFZhbHVlIiwibGFzdEZvcm1hdHRlZFZhbHVlIiwiY3VyVmFsdWUiLCJjdXJDYXJldFBvcyIsImJvdW5kYXJ5IiwiaXNWYWxpZElucHV0Q2hhcmFjdGVyIiwiaXNDaGFyYWN0ZXJTYW1lIiwiZmlyc3RBbGxvd2VkUG9zaXRpb24iLCJmaW5kSW5kZXgiLCJiIiwicHJlZml4Rm9ybWF0Iiwic2xpY2UiLCJzdGFydHNXaXRoIiwiY3VyVmFsTG4iLCJmb3JtYXR0ZWRWYWx1ZUxuIiwiYWRkZWRJbmRleE1hcCIsImluZGV4TWFwIiwiakxuIiwiaXNDaGFyU2FtZSIsInBvcyIsImVuZEluZGV4Iiwic3RhcnRJbmRleCIsImdldENhcmV0UG9zSW5Cb3VuZGFyeSIsImRpcmVjdGlvbiIsInZhbExuIiwibGFzdEluZGV4T2YiLCJjYXJldFVua25vd25Gb3JtYXRCb3VuZGFyeSIsImJvdW5kYXJ5QXJ5IiwibWFwIiwibG4iLCJCb29sZWFuIiwidXNlSW50ZXJuYWxWYWx1ZXMiLCJkZWZhdWx0VmFsdWUiLCJ2YWx1ZUlzTnVtZXJpY1N0cmluZyIsImZvcm1hdCIsInJlbW92ZUZvcm1hdHRpbmciLCJvblZhbHVlQ2hhbmdlIiwiZ2V0VmFsdWVzIiwibnVtQXNTdHJpbmciLCJ2YWx1ZXMiLCJzZXRWYWx1ZXMiLCJfb25WYWx1ZUNoYW5nZSIsIm5ld1ZhbHVlcyIsInNvdXJjZUluZm8iLCJfdmFsdWUiLCJfdmFsdWVJc051bWVyaWNTdHJpbmciLCJkZWZhdWx0UmVtb3ZlRm9ybWF0dGluZyIsImRlZmF1bHRGb3JtYXQiLCJOdW1iZXJGb3JtYXRCYXNlIiwicHJvcHMiLCJ0eXBlIiwiZGlzcGxheVR5cGUiLCJjdXN0b21JbnB1dCIsInJlbmRlclRleHQiLCJnZXRJbnB1dFJlZiIsImlzQWxsb3dlZCIsIm9uQ2hhbmdlIiwib25LZXlEb3duIiwib25Nb3VzZVVwIiwib25Gb2N1cyIsIm9uQmx1ciIsInByb3BWYWx1ZSIsImdldENhcmV0Qm91bmRhcnkiLCJvdGhlclByb3BzIiwicmVmXzAiLCJvbkZvcm1hdHRlZFZhbHVlQ2hhbmdlIiwiY2FyZXRQb3NpdGlvbkJlZm9yZUNoYW5nZSIsImxhc3RVcGRhdGVkVmFsdWUiLCJzb3VyY2UiLCJyZWYkMSIsIm1vdW50ZWQiLCJzZXRNb3VudGVkIiwiZm9jdXNlZEVsbSIsInRpbWVvdXQiLCJzZXRDYXJldFRpbWVvdXQiLCJmb2N1c1RpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJfZm9ybWF0IiwiZ2V0VmFsdWVPYmplY3QiLCJzZXRQYXRjaGVkQ2FyZXRQb3NpdGlvbiIsInNldFRpbWVvdXQiLCJjb3JyZWN0Q2FyZXRQb3NpdGlvbiIsImdldE5ld0NhcmV0UG9zaXRpb24iLCJpbnB1dFZhbHVlIiwiY2FyZXRCb3VuZGFyeSIsInVwZGF0ZWRDYXJldFBvcyIsInVwZGF0ZVZhbHVlQW5kQ2FyZXRQb3NpdGlvbiIsInBhcmFtcyIsImlucHV0IiwiZXZlbnQiLCJsYXN0TnVtQXNTdHJpbmciLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwiZm9ybWF0SW5wdXRWYWx1ZSIsInRhcmdldCIsImNoYW5nZVJhbmdlIiwiY2hhbmdlTWV0YSIsImFzc2lnbiIsIl9udW1Bc1N0cmluZyIsIl9mb3JtYXR0ZWRWYWx1ZSIsImlucHV0JDEiLCJzZXRDYXJldFBvc2l0aW9uSW5mb0JlZm9yZUNoYW5nZSIsImVuZE9mZnNldCIsIl9vbkNoYW5nZSIsImNoYW5nZWQiLCJfb25LZXlEb3duIiwia2V5IiwiZXhwZWN0ZWRDYXJldFBvc2l0aW9uIiwiaXNBcnJvd0tleSIsIm5ld0NhcmV0UG9zaXRpb24iLCJwcmV2ZW50RGVmYXVsdCIsIl9vbk1vdXNlVXAiLCJjb3JyZWN0Q2FyZXRQb3NpdGlvbklmUmVxdWlyZWQiLCJjYXJldFBvc2l0aW9uIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiX29uRm9jdXMiLCJwZXJzaXN0IiwiY3VycmVudFRhcmdldCIsIl9vbkJsdXIiLCJpbnB1dE1vZGUiLCJpbnB1dFByb3BzIiwiY3JlYXRlRWxlbWVudCIsIkZyYWdtZW50IiwiQ3VzdG9tSW5wdXQiLCJkZWNpbWFsU2NhbGUiLCJwcmVmaXgiLCJzdWZmaXgiLCJnZXRTZXBhcmF0b3JzIiwiaGFzRGVjaW1hbFNlcGFyYXRvciIsImFsbG93ZWREZWNpbWFsU2VwYXJhdG9ycyIsImhhbmRsZU5lZ2F0aW9uIiwibmVnYXRpb25SZWdleCIsIlJlZ0V4cCIsImRvdWJsZU5lZ2F0aW9uUmVnZXgiLCJyZW1vdmVOZWdhdGlvbiIsImdldE51bWJlclJlZ2V4IiwiZ2xvYmFsIiwiaXNOdW1lcmljU3RyaW5nIiwiaXNCZWZvcmVEZWNpbWFsU2VwYXJhdG9yIiwic2VwYXJhdG9yIiwic3RyaXBOZWdhdGlvbiIsImhhc0RvdWJsZU5lZ2F0aW9uIiwiY2hhcnNUb1JlbW92ZSIsInRvTWV0YWRhdGEiLCJmcm9tU3RhcnQiLCJmcm9tRW5kIiwidXBkYXRlZFN1ZmZpeFBhcnQiLCJzdWZmaXhTdGFydEluZGV4IiwiZW5kc1dpdGgiLCJmaXJzdEluZGV4IiwicmVmJDIiLCJmaWxsIiwidmFsaWRhdGVBbmRVcGRhdGVQcm9wcyIsIkVycm9yIiwiY29uc29sZSIsImVycm9yIiwidXNlTnVtZXJpY0Zvcm1hdCIsIl9kZWNpbWFsU2VwYXJhdG9yIiwiX2FsbG93ZWREZWNpbWFsU2VwYXJhdG9ycyIsImFsbG93TGVhZGluZ1plcm9zIiwicmVzdFByb3BzIiwiX3JlbW92ZUZvcm1hdHRpbmciLCJyb3VuZEluY29taW5nVmFsdWVUb1ByZWNpc2lvbiIsInJlZiQxXzAiLCJpbmNsdWRlcyIsIl90aG91c2FuZFNlcGFyYXRvciIsImlucHV0Q2hhciIsImN1ckNoYXIiLCJuZXdDaGFyIiwidHlwZWRSYW5nZSIsIk51bWVyaWNGb3JtYXQiLCJudW1lcmljRm9ybWF0UHJvcHMiLCJmb3JtYXQkMSIsImFsbG93RW1wdHlGb3JtYXR0aW5nIiwicGF0dGVybkNoYXIiLCJoYXNoQ291bnQiLCJmb3JtYXR0ZWROdW1iZXJBcnkiLCJyZW1vdmVGb3JtYXR0aW5nJDEiLCJpc051bWVyaWNTbG90IiwicmVtb3ZlRm9ybWF0Q2hhciIsInN0cmluZyIsImV4dHJhY3ROdW1iZXJzIiwiZmlyc3RTZWN0aW9uIiwibWlkZGxlU2VjdGlvbiIsImxhc3RTZWN0aW9uIiwiZ2V0Q2FyZXRCb3VuZGFyeSQxIiwiZmlyc3RFbXB0eVNsb3QiLCJtYXNrQW5kSW5kZXhNYXAiLCJmb3JFYWNoIiwibWFza0F0SW5kZXgiLCJpc1Bvc0FsbG93ZWQiLCJ2YWxpZGF0ZVByb3BzIiwibWFza0FzU3RyIiwiaXNOdW1lcmljU3RyaW5nJDEiLCJ1c2VQYXR0ZXJuRm9ybWF0IiwiZm9ybWF0UHJvcCIsIl9nZXRDYXJldEJvdW5kYXJ5IiwiZm9ybWF0TG4iLCJpc1ZhbHVlTnVtZXJpY1N0cmluZyIsIl9wcm9wcyIsIlBhdHRlcm5Gb3JtYXQiLCJwYXR0ZXJuRm9ybWF0UHJvcHMiLCJnZXROdW1lcmljQ2FyZXRCb3VuZGFyeSIsImdldFBhdHRlcm5DYXJldEJvdW5kYXJ5IiwibnVtZXJpY0Zvcm1hdHRlciIsInBhdHRlcm5Gb3JtYXR0ZXIiLCJyZW1vdmVOdW1lcmljRm9ybWF0IiwicmVtb3ZlUGF0dGVybkZvcm1hdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-number-format/dist/react-number-format.es.js\n");

/***/ })

};
;